#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Mar  8 16:05:25 2018

@author: Zaid
"""
import importlib.util
import random

    
def print_links(link_list,a):
    spec = importlib.util.find_spec('colorama')
    if spec:
        from colorama import Fore, Back, Style

        print (Back.CYAN,Style.BRIGHT)
        print("{:<20} {:<25} {:<25} {:<25} ".format('source router id', "(src router, src group)", "(dest router, dest group)",' dest router id'))
        print(Style.RESET_ALL,Fore.BLUE)

        for s,d in link_list:
            print("\t{:<20} {:<25} {:<25} {:<25} ".format(s, "(" + str(s%a) + "," + str(s//a) + ")",
                                                        "(" + str(d%a) + "," + str(d//a) + ")", d))
        print(Style.RESET_ALL)

    else:
        print("{:<20} {:<25} {:<25} {:<25} ".format('source router id', "(src router, src group)",
                                                    "(dest router, dest group)", ' dest router id'))
        for s,d in link_list:
            print("\t{:<20} {:<25} {:<25} {:<25} ".format(s, "(" + str(s%a) + "," + str(s//a) + ")",
                                                        "(" + str(d%a) + "," + str(d//a) + ")", d))

'''notation:
h: number of global links per router
n: the total number of routers in the network
g: total group number
a: number of routers in each group
'''

''' - originals arrangements:

1- absolute: allocation of global links consists of connecting the routers in each group in consecutive order, with the groups in the
network also in consecutive order, always starting from group 0 and skipping those links with source and destination being in the same group.

'''


def global_links_arrangment(name,a,g,h, seed = 0):

    global_link = []

    if name == 'absolute':
        #the table header

        for j in range(g):
                for i in range(a):
                    for k in range(h):
                        dg = i * h + k
                        if dg < j :
                            ds = (j-1)//h
                            ds %= a
                        else:
                            ds = j//h
                            dg += 1
                            dg %= g

                        global_link.append((((j*a)+i),(dg*a)+ds))
    

    '''                         
    2- relative: allocation of global links consists of connecting the first half of the routers in the first half of the groups to the second half of the routers of the second half of the groups.
    
    originally, there are two different implementations; one works only on the maximum number of groups (a*h + 1), the other one works on some cases where g < max number of groups.
    
    '''
    if name == 'relative':
    
    #the table header

        for j in range(g):
                for i in range(a):
                    for k in range(1, h + 1):
                        dg = (j + 1 + (((a - i - 1) * h + k - 1)) % (g - 1))%g #extended
                        #dg = (j -(i * h) - k)% g # original
                        ds =  a - i - 1
                        global_link.append(((j * a) + i, (dg * a) + ds))
    
    '''
    3- circulant: allocation of global links consists of connecting half of 
    the global links for a group with the successor groups and the other half to the predecessor groups.
    
    '''
    
    if name == 'circulant' :
        import operator
    
        ops = {"+": operator.add,"-": operator.sub}

        for j in range(g):
                for i in range(a):
                    for k in range(0, (h // (2))):
                        for o in ops:
                            op_func = ops[o]
                            dg = (op_func(j, (((h // 2) * i + k) % (g - 1 // 2)) + 1))%g
                            ds = i
                            global_link.append(((j * a) + i, (dg * a) + ds))
    '''
    
    - the improved arrangement for originals ones
    4- absolute improved: similar to the absolute method but it shifts the destination switch index by one every time all groups are visited.
    Therefore, the result of this arrangement is not isomorphic to absolute (in the cases where absolute is work), and it slightly lowers the load in the local links because it increases the number of 2 hops paths and decrees the number of 3 hops paths. Unlike absolute arrangement, this works on any number of groups.
    
    '''
    if name == 'absolute_improved':
        nodes = a * g
        dg = 1
        ds = 0
        
        node_degree = [0] * nodes

        for j in range(g):
            
            for i in range(a):
        
                while node_degree[(j*a)+i] < h:
                            
                    if dg != j and node_degree[(a* dg)+ds]< h:

                        node_degree[(a*j)+i] += 1
                        node_degree[(a*dg)+ds] += 1

                        global_link.append(((j * a) + i, (dg * a) + ds))

                    dg += 1
                    if dg % g == 0:
                        ds += 1
                        ds %= a
                        dg %= g

    
    '''
    - absolute improved2: this will iterate over group instead of the nodes inside the groups.
    '''
    
    if name == "absolute_improved2":
        from collections import deque
        import random 
        random.seed(seed)

        nodes = a * g
        dg = 1
        ds = 0
        
        node_degree = [0] * nodes

        for i in range(a):
            
            for j in range(g):
        
                while node_degree[(j*a)+i] < h:
                            
                    if dg != j and node_degree[(a* dg)+ds]< h:

                        node_degree[(a*j)+i] += 1
                        node_degree[(a*dg)+ds] += 1
                        global_link.append(((j * a) + i, (dg * a) + ds))

                    dg += 1
                    if dg % g == 0:
                        ds += 1
                        ds %= a
                        dg %= g
    
    '''
    5- relative improved:  an improved version of relative arrangement that visit have of the nodes and make bidirectional links instead of unidirectional links, therefore, it works on any number of groups.
    '''
    
    if name == 'relative_improved':
    #the table header
        swithes = [[x + y for y in range(a // 2)] for x in range(0, g * a, a // 2)[::2]]
        
        for switch_list in swithes:
            for switch in switch_list:
                j = switch // a
                i = switch % a
        
                loop = 0
                for dg in range(j + (i * h) + 1, j + (i * h) + h + 1):
                    # connect to nodes in the next h groups
                    # print(next_g)
                    if (dg + loop) % g == j:
                        loop += 1
                    dg = (dg + loop) % g
                    ds = a - i
                    connect_to = (dg * a) + ds - 1
                    global_link.append((switch, connect_to))
    
    
    '''
    - new random approach 
    6- random: in this arrangement, the algorithm randomly picks two groups with least global links then randomly select switch with the least connections in each group and connect them. Repeated until each switch has the required degree.
    This approach results in disconnected groups.
    
    '''
    if name == 'random':
        from collections import deque
        import random 
        random.seed(seed)
        nodes = a * g
        
        node_degree = [0] * nodes
        
        group_fill = [[0, x, deque([(x * a) + y for y in range(a)]), [0] * g] for x in range(g)]
        
        for group in group_fill:
            random.shuffle(group[2])
        
        while sum([x[0] for x in group_fill]) < g * a * h:

            srcDst = []
            random.shuffle(group_fill)
            for i in range(2):
                minG = min(group_fill, key=lambda x: x[0])
                while len(srcDst) > 1 and minG[1] == srcDst[0]:
                    random.shuffle(group_fill)
        
                    minG = min(group_fill, key=lambda x: x[0])
                minG[0] += 1
                srcDst += [minG[1], minG[2][-1]]

                if node_degree[minG[2][-1]] == h - 1:
                    minG[2].pop()

            src_g, src, dest_g, dest = srcDst

            global_link.append((src,dest))
            global_link.append((dest, src))

            node_degree[src] += 1
            node_degree[dest] += 1
        
        #print(node_degree)
    '''
    
    7-  greedy random: in this global links arrangement, we start by making one links between every two groups, then make the random method.
    
    '''
    if name == 'greedy_random':
        from collections import deque
        import random 
        random.seed(seed)
        
        nodes = a * g
        
        node_degree = [0] * nodes
        
        group_fill = [[0, x, deque([(x * a) + y for y in range(a)]), [0] * g] for x in range(g)]

        for group in group_fill:
            random.shuffle(group[2])

        initLinks = ((x, y) for x in range(g) for y in range(x + 1, g))
        group_fill.sort(key=lambda x: x[1])

        while sum([x[0] for x in group_fill]) < g * a * h:

            srcDst = []
            if sum([x[0] for x in group_fill]) < (g * (g - 1)):
                for x in next(initLinks):
                    minG = group_fill[x]
                    minG[0] += 1
                    srcDst += [minG[1], minG[2][-1]]
                    if node_degree[minG[2][-1]] == h - 1:
                        minG[2].pop()
            else:
                random.shuffle(group_fill)
                for i in range(2):
                    minG = min(group_fill, key=lambda x: x[0])
                    while len(srcDst) > 1 and minG[1] == srcDst[0]:
                        random.shuffle(group_fill)
                        minG = min(group_fill, key=lambda x: x[0])
                    minG[0] += 1
                    srcDst += [minG[1], minG[2][-1]]

                    if node_degree[minG[2][-1]] == h - 1:
                        xx = minG[2].pop()
            src_g, src, dest_g, dest = srcDst
            node_degree[src] += 1
            node_degree[dest] += 1
            global_link.append((src, dest))
            global_link.append((dest, src))
        
    '''
    
    8- leftover greedy random: in this arrangement, the algorithm begins by t round
     of absolute_imporved or greedy random, then use a greedy random approach to link the leftover links.
    t = (a * h)/(g-1)  
    
    '''
    # start with random greedy
    if name == 'leftover_greedy_random1':
        from collections import deque
        import random
        random.seed(seed)
        nodes = a * g
        
        node_degree = [0] * nodes
        
        group_fill = [[0, x, deque([(x * a) + y for y in range(a)]), [0] * g] for x in range(g)]
        for group in group_fill:
            random.shuffle(group[2])

        initLinks = ((x, y) for x in range(g) for y in range(x + 1, g))
        initLks = len(list(initLinks))
        total_globals = (h * a * g)//2
        
        mult = total_globals // initLks
        #print("{:<20} {:<25} {:<25} {:<25} ".format('source router id', "(src router, src group)","(dest router, dest group)" ,' dest router id'))
        
        group_fill.sort(key=lambda x: x[1])
        while sum([x[0] for x in group_fill]) < g * a * h:
            if sum([x[0] for x in group_fill]) % initLks == 0 and sum([x[0] for x in group_fill]) < mult * initLks:
                initLinks = ((x, y) for x in range(g) for y in range(x + 1, g))

            srcDst = []
            if sum([x[0] for x in group_fill]) < (g * (g - 1)):
                for x in next(initLinks):
                    minG = group_fill[x]
                    minG[0] += 1
                    srcDst += [minG[1], minG[2][-1]]
                    if node_degree[minG[2][-1]] == h - 1:
                        minG[2].pop()
            else:
                random.shuffle(group_fill)
                for i in range(2):
                    minG = min(group_fill, key=lambda x: x[0])
                    while len(srcDst) > 1 and minG[1] == srcDst[0]:
                        random.shuffle(group_fill)
                        minG = min(group_fill, key=lambda x: x[0])
                    minG[0] += 1
                    srcDst += [minG[1], minG[2][-1]]

                    if node_degree[minG[2][-1]]== h - 1:  #
                        xx = minG[2].pop()

            src_g, src, dest_g, dest = srcDst
            node_degree[src] += 1
            node_degree[dest] += 1
            global_link.append((src, dest))
            global_link.append((dest, src))
    
    # start with absulute_improved
    if name == 'leftover_greedy_random2':     
        import random
        random.seed(seed)
        nodes = a * g
        
        node_degree = [0] * nodes

        nodes = a * g
        dg = 1
        ds = 0

        left_over_links = (((h * a) % (g - 1)))
        
        node_degree = [0] * nodes

        for j in range(g):
        
            for i in range(a):
        
                while node_degree[(j * a) + i] < h and sum(node_degree[a*j:a*j+a]) <= (a*g)- left_over_links:
        
                    if dg != j and node_degree[(a * dg) + ds] < h:

                        global_link.append(((a * j) + i, (a * dg) + ds))

                        node_degree[(a * j) + i] += 1
                        node_degree[(a * dg) + ds] += 1
        
                    dg += 1
                    if dg % g == 0:
                        ds += 1
                        ds %= a
                        dg %= g
        
        while node_degree.count(h) < nodes:
            left_sws_per_group = [[] for x in range(g)]
            for sw, d in enumerate(node_degree):
                if d < h:
                    left_sws_per_group[sw // a].append((sw // a, sw % a))
        
            random.shuffle(left_sws_per_group)
        
            for l in left_sws_per_group:
                random.shuffle(l)
                deque(l)
        
            for i, sg in enumerate(left_sws_per_group):
                for src_g, src in sg:
                    dest_g = left_sws_per_group[(i + 1) % len(left_sws_per_group)]
        
                    if dest_g == src_g:
                        continue
                    ds = random.choice(dest_g)
        
                    if node_degree[(a * dest_g) + ds] == h or node_degree[(a * src_g) + src] == h:
                        continue
        
                    node_degree[(a * dest_g) + ds] += 1
                    node_degree[(a * src_g) + src] += 1

                    global_link.append(((a * dest_g) + ds, (a * src_g) + src))

    return global_link


if __name__ == "__main__":
    print("Hello World from global_links_arrangement!")
    

#import sys
# arrangm_list  = ['absolute','relative','circulant','absolute_improved','absolute_improved2','relative improved','random','greedy_random','leftover_greedy_random1','leftover_greedy_random2']
# nodes = list(range(4*9))
# #arrangm_list=['random']
# for arr in arrangm_list:
#     s_d_list = global_links_arrangment(arr,4,9,2)
#     print(arr)
#     print(len(s_d_list))
#
#     global_links = {}
#     #
#
#     for (switch, connect_to) in s_d_list:
#
#         if (switch, connect_to) in global_links or (connect_to, switch) in global_links:
#             continue
#
#         t1 = s_d_list.count((switch, connect_to))
#         t2 = s_d_list.count((connect_to, switch))

#
#         max_w = max(t1, t2)
#
#         for link in [(switch, connect_to), (connect_to, switch)]:
#             global_links[link] = dict()
#             global_links[link]['w'] = max_w  # G[switch][connect_to]['wight']
#             global_links[link]['load'] = 0
#             global_links[link]['count'] = 0
#     #print(sum([[x for s,d in global_links for x in nodes if s == x or x == d].count(y) for y in nodes]))
#     print(sum([x['w'] for x in global_links.values()]))
#     for x in global_links:
#         print(x)

#arrangm_list  = ['absolute','relative','circulant','absolute_improved','absolute_improved2','relative improved','random','greedy_random','leftover_greedy_random1','leftover_greedy_random2']
# if len(sys.argv) < 4:
#     print("\nusage:./global_links_arrangment.py arrangment_index a g\n")
#     [ print(i+1 ,' ',x) for i,x in enumerate(arrangm_list) ]
#     print("\n")
#     exit(1)
#
# gl = global_links_arrangment(arrangm_list[int(sys.argv[1])],int(sys.argv[2]),int(sys.argv[3]),int(sys.argv[2])//2)
# print_links(gl , int(sys.argv[2]))
