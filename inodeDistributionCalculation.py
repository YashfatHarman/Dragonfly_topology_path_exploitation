#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Apr 30 15:10:39 2019

@author: rahman
"""

'''
Take a small Dragonfly (a 8 g 5).
Take all router SD pairs (all-to-all traffic).
For each pair, get i-node count for:
    3hop, 4hop, (4hop-3hop), 5hop, (5hop-4hop), 6hop(all), (6hop-5hop)    
'''
from test_jains_and_mcf import create_topology_and_pathlist
from intro_code_to_test_something import draw_graph_circular
import Dragonfly_paths as DP
from mcf import inode_generator_empty, inode_generator_vanilla, inode_generator_5hop_src_and_dst, inode_generator_5hop_src_only, inode_generator_3hop_and_4hop, inode_generator_4hop_and_5hop, inode_generator_5hop_and_6hop, inode_generator_for_3hop_paths, inode_generator_for_4hop_paths

import pandas as pd

def calculate_inode_distribution_for_a_pair(src_router, dst_router, **inodegenerator_kwargs):
    #for each SD pair, need to call the appropriate i-node generator
    
    #For each pair, get i-node count for:
    #    3hop, 4hop, (4hop-3hop), 5hop, (5hop-4hop), 6hop(all), (6hop-5hop)    

    #3hop
    inodes_3hop = inode_generator_for_3hop_paths(src_router, dst_router, **inodegenerator_kwargs)
    c3hop = len(inodes_3hop)
    
    inodes_4hop = inode_generator_for_4hop_paths(src_router, dst_router, **inodegenerator_kwargs)
    c4hop = len(inodes_4hop)
    
    inodes_5hop = inode_generator_5hop_src_only(src_router, dst_router, **inodegenerator_kwargs)
    c5hop = len(inodes_5hop)
    
    inodes_6hop = inode_generator_vanilla(src_router, dst_router, **inodegenerator_kwargs)
    c6hop = len(inodes_6hop)
    
    counts = (src_router, dst_router, c3hop, c4hop, c5hop, c6hop) 
    
    return counts
    
    pass

def all_to_all_pattern(a,g):
    #    for src in range(N):
    #        for dst in range(N):
    #            if src != dst:
    #                yield (src,dst)
    res = []
    N = a * g
    for src_r in range(N):
        for dst_r in range(N):
            src_group = src_r // a
            dst_group = dst_r // a
            if src_r == dst_r or src_group == dst_group:
                continue
            else:
                res.append((src_r, dst_r))
    return res
    
def _generate_inode_kwargs(*,G, a, g, p, sd_pairs):
    _graph_adj_list = DP.generate_graph_adjacency_list(G)
    _group_pair_vs_nodes = DP.generate_list_of_nodes_connected_to_group_pairs(_graph_adj_list, a)
    _group_pair_vs_global_links = DP.get_list_of_links_between_each_group_pair(G, edge_weight = "w", a = a, g = g )
    
    twoHopNeighborList =  DP.generate_list_of_2hop_neighbors(G, _group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
    sd_pair_vs_3hop_inodes = DP.inodes_for_3hop_paths_for_all_SD_pairs(sd_pairs, G, _graph_adj_list, twoHopNeighborList, edge_weight = "w", a = a, g = g, p = p)
    sd_pair_vs_4hop_inodes = DP.inodes_for_4hop_paths_for_all_SD_pairs(sd_pairs, G, _graph_adj_list, _group_pair_vs_nodes, edge_weight = "w", a = a, g = g, p = p)
    
    inodegenerator_kwargs = {"N" : a*g, 
                             "a" : a, 
                             "twoHopNeighborList" : twoHopNeighborList, 
                             "sd_pair_vs_4hop_inodes" : sd_pair_vs_4hop_inodes, 
                             "sd_pair_vs_3hop_inodes" : sd_pair_vs_3hop_inodes, 
                             #"mode_param" : mode_param
                             }
    
    return inodegenerator_kwargs


def inode_dsitribution_driver():
    #create topology
    a = 8
    g = 9
    p = 1 #router level traffic
    arrangement = "absolute_improved"
    G, all_min_paths_DF, all_djkstra_paths = create_topology_and_pathlist(a,g,arrangement)
    
    print("a {}  g {}".format(a,g))
    
    #draw it
    #draw_graph_circular(G, a = a)
    
    #create all-to-all pattern
    sd_pairs = all_to_all_pattern(a, g)    
    
    inodegenerator_kwargs = _generate_inode_kwargs(G = G, a = a, g = g, p = p, sd_pairs = sd_pairs)
    
    count_results = []
    for pair in sd_pairs:
        counts = calculate_inode_distribution_for_a_pair(pair[0], pair[1], **inodegenerator_kwargs)
        count_results.append(counts)
        
        
    df = pd.DataFrame(count_results)
    df.columns = ["src_r","dst_r","c3","c4","c5","c6"]
    df["c4_3"] = df["c4"] - df["c3"]
    df["c5_4"] = df["c5"] - df["c4"]
    df["c6_5"] = df["c6"] - df["c5"]
    #print(df.shape)
    #print(df.head(20))
    
    columns_we_care = ["c3","c4", "c5_4", "c5","c6"]
    print(columns_we_care)
    
    for column in columns_we_care:
        print("\ncolumn {} freqencies:".format(column))
        count= df[column].value_counts()
        #print(count)
        for i,r in sorted(count.iteritems(), reverse = True):
            print(i,r)
        #now think of how to summarize it
    
    pass

if __name__ == "__main__":
    print("Hellow World!")
    inode_dsitribution_driver()
    print("Done")