#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Mar 18 14:39:18 2018


"""

import networkx as nx
import traffic as tf
import global_links_arrangment as gl
import matplotlib.pyplot as plt
import pprint
import math
import time




def jains_model_old(G, sd, pp, nn,  pl=None):
    '''
    Based on Zaid's initial implementation.
    Has bugs.
    Decided to scrap it altogether write a new one.
    Will help in the long run if I want to further modify it.
    '''
    
    '''
    pp : # of processes (processing nodes, it seems)
    nn : # of switches
    sd : source-destination list
    pl : path-list. If not passed, then nx.all_shortest_paths() will be used instead.
    '''

    print("inside jains.")

    load = {}
    all_flows = []
    std_paths = 0
    count = 0
    # pl= None
    
    for edg in list(G.edges()):
        t1 = time.time()
        load[edg] = {'used': 0, 'cap': G[edg[0]][edg[1]]['cap'], 'path_count': 0}
        load[edg[::-1]] = {'used': 0, 'cap': G[edg[0]][edg[1]]['cap'], 'path_count': 0}

    #    print("initial load distribution:")
    #    for k,v in sorted(load.items()):
    #        print(k,v)
    #        
    # count use

    print("usage count starts ...")
    for s, d in sd:
        pathes = []
        #        if r == 'min':

        if s == d:
            # print (s,d)
            count += 1
            continue
        
        if pp:
            s = (s - nn) // pp
            d = (d - nn) // pp
            # print(s,d)

        if s == d:
            # print (s,d)
            count += 1
            continue

        if not pl:
            pathes.append(list(nx.all_shortest_paths(G, s, d, weight='w')))
        else:

            #pathes = pl[s][d]
            pathes = pl[(s,d)]
            print(pathes)
            
        temp = {'paths': list(), 'src': s, 'dest': d, 'count': len(pathes), 'flow_size': 0, 'rem': 1,
                'load_per_path': 1}
        l = []

        for path in pathes:

            l.append({'p': path, 'bw': 0, 'flow_size': 1, 'sat': 0, 'rem': 1})

            for n in range(len(path) - 1):
                load[(path[n], path[n + 1])]['path_count'] += 1

        temp['paths'] = l
        all_flows.append(temp)
    print("usage count ends ...")
    
    print("load distribution after the usage-count loop:")
    for k,v in sorted(load.items()):
        print(k,v)
    
    print("contents of all_flows:")
    for flow in all_flows:
        print(flow)
        print()

    # update BW and rate for each flow

    print("\nStarting the initial loop:")
    for flow in all_flows:
        #        print("\nsrc:", flow["src"], "dest:",flow["dest"])
        for path in flow['paths']:

            #            print(path)
            # max_l = min([value['cap']/value['path_count'] for key, value in load.items() if key in [(path['p'][x],path['p'][x+1]) for x in range(len(path['p']) - 1)]])
            
            max_l = float('inf')
            
            for x in range(len(path['p']) - 1):
                max_l = min( load[(path['p'][x], path['p'][x + 1])]['cap'] / load[(path['p'][x], path['p'][x + 1])][
                    'path_count'], max_l)
            #
            if path['sat']:
                continue

            path['bw'] = min(flow['load_per_path'], max_l)
                #what is the significance of load_per_path? *************

            for n in range(len(path['p']) - 1):

                load[(path['p'][n], path['p'][n + 1])]['used'] += max_l   
                        #changed from path["bw"]. shouldnt make any differnece in this case though

                if load[(path['p'][n], path['p'][n + 1])]['used'] >= load[(path['p'][n], path['p'][n + 1])]['cap']:
                    std_paths += 1
                    #                    print(std_paths," flows saturated out of ",len(all_flows))
                    path['sat'] = 1

    print("initial iteration done ...")
    #    print("link load distribution after the first iteration:")
    #    for k,v in sorted(load.items()):
    #        print(k,v)
    #    

    saturated = False

    counter = 1
    
#    while not saturated:
#        
#        if counter % 500 == 0:
#            print("main iteration. iteration count: ", counter)
#
#        saturated = True
#
#        for link, properties in load.items():
#            properties['path_count'] = 0
#            properties['flow_list'] = []
#
#        #here it is checking if any path is left to be saturated
#        for flow in all_flows:
#
#            for path in flow['paths']:
#                #                print("path being considered:", path)
#                #                if path['sat'] or [value['used'] for key, value in load.items() if key in [(path['p'][x],path['p'][x+1]) for x in range(len(path['p']) - 1)] if value['used']>= value['cap']]:
#                #                    path['sat'] = 1
#                #                    continue
#                for x in range(len(path['p']) - 1):
#                    if load[(path['p'][x], path['p'][x + 1])]['used'] >= load[(path['p'][x], path['p'][x + 1])]['cap']:
#                        path['sat'] = 1
#                        break
#                    #print("path after saturation check:", path)
#                        
#                if path['sat']:
#                    continue
#
#                else:
#                    saturated = False
#                    #print("saturated set to False")
#
#                for n in range(len(path['p']) - 1):
#                    load[(path['p'][n], path['p'][n + 1])]['path_count'] += 1
#                    
#        #here, for any path that is not saturated, additional flow_rate is allocated to it.
#        #print("here")
#        if not saturated:
#            for flow in all_flows:
#    
#                for path in flow['paths']:
#    
#                    if path['sat']:
#                        continue
#    
#                    # max_l = min([(value['cap'] - value['used'])/value['path_count'] for key, value in load.items() if key in [(path['p'][x],path['p'][x+1]) for x in range(len(path['p']) - 1)]])
#                   
#                    #here, finding the max amount of flow_rate that can be allocated to path. 
#                    #it is equal to the amount of the remaining b/w in the bottleneck link in the path
#                    max_l = float('inf')
#                    for x in range(len(path['p']) - 1):
#                        max_l = min( (load[(path['p'][x], path['p'][x + 1])]['cap'] - load[(path['p'][x], path['p'][x + 1])][
#                            'used']) / load[(path['p'][x], path['p'][x + 1])]['path_count'], max_l)
#                    path['bw'] += max_l
#    
#                    # print(path)
#                    
#                    #here after selecting the additional flow_rate, used bw and remaining bw is updated for each link. 
#                    #if a link uses equal or more b/w than its capacity, the corresponding path is declared saturated.
#                    for n in range(len(path['p']) - 1):
#                        #load[(path['p'][n], path['p'][n + 1])]['used'] += path['bw'] ****seems like a bug
#                        load[(path['p'][n], path['p'][n + 1])]['used'] += max_l
#                        
#                        if load[(path['p'][n], path['p'][n + 1])]['used'] >= load[(path['p'][n], path['p'][n + 1])]['cap']:
#                            path['sat'] = 1
#                                #this is actually redundant, and ineffective.
#                                #whether a path is saturated or not is checked at the beginning of each iteration.
#                                #so this check here unnecessary.
#                                #also, if three paths cause a link to get saturated, only the third one will be 
#                                    #identified as saturated with this check.
#                            
#        #        print("\nlink load distribution after the iteration:", counter)
#        #        for k,v in sorted(load.items()):
#        #            print(k,v)
#        #        print("contents of all_flows:")
#        #        for flow in all_flows:
#        #            print(flow)
#        #        print("saturated?", saturated)
#        #print("here2")
#        counter += 1
#        #print("here3")
#
#    throuput = 0
#    for flow in all_flows:
#        for path in flow['paths']:
#            throuput += path['bw']
#    # [print(x,'\t',y['used']) for x,y in load.items()]
#    return throuput / len(sd)
    return 1


def jains_model(G, traffic, path_list, *, verbose = False):
    '''
    G: a networkx graph object
    
    traffic: traffic pattern.  A list of (s,d) tuples.
    
    path_list: A dict of (s,d) pair keys and list_of_paths_between_that_sd_pair in values.
            list_of_paths_between_that_sd_pair is list of tuples. Each tuple contains the node ids in the path.
    '''
    
    #TODO
    #An emergency measure to get rid of flows where src == dst.
    #Will need to decide the proper way to deal with them later.
    filtured_traffic = [x for x in traffic if x[0] != x[1]]
    if verbose:
        print("filtured traffic len:", len(filtured_traffic))
    traffic = filtured_traffic
    
    if verbose:
        print("\nInside jains ...")
    
    #for each link, we need to keep track of:
    #its remaining capacity and if it is saturated.
    #Also, we need to know how many paths use this link (usage_count).
    #usage_count will be updated after each iteration to only consider the (yet) unsaturated paths
    
    all_links = {}
    
    for link in G.edges():
        all_links[link] = {"remaining_capacity": G[ link[0] ][ link[1] ]['cap'], "saturated": False, "usage_count" : 0 }
        # We are using bidirectional links in networkX.
        # So for links A-B and B-A, networkX will only have one of them.
        # But for our calculations, we want both of them separately.
        all_links[(link[1],link[0])] = {"remaining_capacity": G[ link[0] ][ link[1] ]['cap'], "saturated": False, "usage_count" : 0 }

    if verbose:
        print_link_stats(all_links)

    #for each flow, we need to keep track of:
        #each path in it
        #if the flow is saturated
        #also, src and dst of the flow
    #For each path, we need to keep track of:
        #is the path saturated
        #allocated b/w
    
    #because we will go through the flows sequentially, it's better to have them in a list
    all_flows = [None for x in range(len(traffic))]
    
    for flow_id,(src,dst) in enumerate(traffic):
        
        if verbose:
            print("src,dst:", src,dst)
        
        temp_flow_object = {   "src" : src,
                                 "dst" : dst,
                                 "saturated" : False,
                                 "path_objects" : [],
                                 "path_count" : 0,
                                 "unsaturated_path_count" : 0}
        
        temp_flow_object["path_objects"] = [None for x in range(len(path_list[(src,dst)]))]
        
        for path_id, path in enumerate(path_list[(src,dst)]):
            temp_path_object = {"path": path,
                                "saturated" : False,
                                "allocated_bw" : [] }
                    #allocated_bw is a list to hold the allocated_bw portion in each iteration.
                    #so if a link gets 0.50, 0.25 and 0.10 in three iterations, allocated_bw will be [0.50, 0.25, 0.10]
            temp_flow_object["path_objects"][path_id] = temp_path_object
            
        temp_flow_object["path_count"] = len(path_list[(src,dst)])
        temp_flow_object["unsaturated_path_count"] = temp_flow_object["path_count"]
        
        all_flows[flow_id] = temp_flow_object
    
    if verbose:
        print_flow_objects(all_flows)
    
    #get initial link-usage info
    #go through each flow
        # go through each path
            #for each link, update the link-usage count
    for flow_object in all_flows:
        for path_object in flow_object["path_objects"]:
            path = path_object["path"]
            for ii in range(len(path) - 1):
                all_links[(path[ii], path[ii+1])]["usage_count"] += 1
    
    if verbose:
        print_link_stats(all_links)


    if verbose:
        print("initialization done.")
    
    #first do a single iteration and see how it goes. 
    
    #each iteration has the following steps:
        # go through each path in each flow and allocate rate
        # go through each path in each flow and update link b/w and mark link saturation
        # go through each path in each flow and mark saturated paths, saturated flows, and update link usage.
    
    unsaturated_flow_count = len(all_flows)
    iteration_count = 0
    
    while unsaturated_flow_count > 0:
    #for iteration_count in range(2):
        if verbose:
            print("start iteration: ", iteration_count)
        
        #iteration will run until all the flows are saturated
        if verbose:
            print("unsaturated flow count:", unsaturated_flow_count)
            
        # go through each path in each flow and allocate rate
        for flow_object in all_flows:
            if flow_object["saturated"] == True:
                continue
            for path_object in flow_object["path_objects"]:
                if path_object["saturated"] == True:
                    continue
                path = path_object["path"]
                #print(path)
                allocated_bw = min([ all_links[path[ii], path[ii+1]]["remaining_capacity"]/all_links[path[ii], path[ii+1]]["usage_count"] for ii in range(len(path) - 1) ])
                path_object["allocated_bw"].append(allocated_bw)
                
        #    if verbose:
        #        print("\nallocated bw after initial pass:")
        #        print_flow_objects(all_flows)
    
        # go through each path in each flow and update link b/w and mark link saturation
        for flow_object in all_flows:
            if flow_object["saturated"] == True:
                continue
            for path_object in flow_object["path_objects"]:
                if path_object["saturated"] == True:
                    continue
                if len(path_object["allocated_bw"]) == iteration_count + 1:
                    #this means the path was allocated some bw in the most recent iteration,
                    #so b/w update is needed in the corresponding links.
                    #Also, iteration_count starts from 0, hence +1
                    path = path_object["path"]
                    for ii in range(len(path)-1):
                        src,dst = path[ii], path[ii+1]
                        all_links[(src,dst)]["remaining_capacity"] -= path_object["allocated_bw"][iteration_count]
                        if all_links[(src,dst)]["remaining_capacity"] <= 0.0000001: 
                            #small enough value to be able to get around rounding error, hopefully
                            all_links[(src,dst)]["saturated"] = True
                            
        #    if verbose:
        #        print("\nupdated bw after initial pass:")
        #        print_link_stats(all_links)
        #    
        # go through each path in each flow and mark saturated paths, and update link usage.
        for flow_object in all_flows:
            if flow_object["saturated"] == True:
                continue
            for path_object in flow_object["path_objects"]:
                if path_object["saturated"] == False:
                    path = path_object["path"]
                    flag = False
                    for ii in range(len(path)-1):
                        src,dst = path[ii], path[ii+1]
                        if all_links[(src,dst)]["saturated"] == True:
                            flag = True
                            path_object["saturated"] = True
                            break
                    
                    #in case a path is saturated, it will not contribute in link_usage any more. So update.
                    if flag == True:
                        for ii in range(len(path)-1):
                            src,dst = path[ii], path[ii+1]
                            all_links[(src,dst)]["usage_count"] -= 1
        
        # now go through the flows one last time to see which flows are saturated
        for flow_object in all_flows:
            if flow_object["saturated"] == False:
                flag = True
                for path_object in flow_object["path_objects"]:
                    if path_object["saturated"] == False:
                        flag = False
                        break
                if flag == True:
                    flow_object["saturated"] = True
                    unsaturated_flow_count -= 1
                        #another flow bites the dust
                    
        if verbose:
            print("\nFlow update after saturation tracking:")
            print_flow_objects(all_flows)
                        
        if verbose:
            print("\nupdated link usage after saturation tracking:")
            print_link_stats(all_links)
        
        if verbose:
            print("end of iteration: ", iteration_count)
        
        iteration_count += 1
        
        #end of iteration loop

    #now calculate the final b/w and return as answer
    total_bw = 0.0
    for flow_object in all_flows:
        for path_object in flow_object["path_objects"]:
            total_bw += math.fsum(path_object["allocated_bw"])
    
    res = total_bw / len(traffic)

    if verbose:
        print("total allocated bw :", total_bw)
        print("final result: ", res)
        
    if verbose:
        print("\nDone with jains ...\n")
        
    return (total_bw, res)
        
    pass

def jains_model_with_unique_pairs(G, traffic_and_freqs, path_list, *, verbose = False):
    '''
    This is a slight modification of the above jains_model() function.
    
    The only difference is the traffic_and_freqs pattern.
    This time we are sending a list of ((s,d), freq) tuple.
    freq is the number of times an (s,d) occurs in the pattern.
    For most of the time, it will be 1.
    
    When we are sure that this one is working, we can get rid of the old one.
    '''
    
    '''
    G: a networkx graph object
    
    traffic_and_freqs: traffic pattern and their frequency. A list of shape ((s,d), freq)
    #traffic: traffic pattern.  A list of (s,d) tuples.
    
    path_list: A dict of (s,d) pair keys and list_of_paths_between_that_sd_pair in values.
            list_of_paths_between_that_sd_pair is list of tuples. Each tuple contains the node ids in the path.
    '''
    
    #splice open the traffics and their frequencies. 
    #Will be easier to incorporate into the exsiting code.
    
    if verbose:
        print("\nInside jains ...")
    
    
    traffic = [x[0] for x in traffic_and_freqs]
    freq = [x[1] for x in traffic_and_freqs]
    
    if verbose:
        print(traffic)
        print(freq)
    
    #TODO
    #An emergency measure to get rid of flows where src == dst.
    #Will need to decide the proper way to deal with them later.
    filtured_traffic = [x for x in traffic if x[0] != x[1]]
    if verbose:
        print("filtured traffic len:", len(filtured_traffic))
    traffic = filtured_traffic
    
    
    #for each link, we need to keep track of:
    #its remaining capacity and if it is saturated.
    #Also, we need to know how many paths use this link (usage_count).
    #usage_count will be updated after each iteration to only consider the (yet) unsaturated paths
    
    all_links = {}
    
    for link in G.edges():
        all_links[link] = {"remaining_capacity": G[ link[0] ][ link[1] ]['cap'], "saturated": False, "usage_count" : 0 }
        # We are using bidirectional links in networkX.
        # So for links A-B and B-A, networkX will only have one of them.
        # But for our calculations, we want both of them separately.
        all_links[(link[1],link[0])] = {"remaining_capacity": G[ link[0] ][ link[1] ]['cap'], "saturated": False, "usage_count" : 0 }

    if verbose:
        print_link_stats(all_links)

    #for each flow, we need to keep track of:
        #each path in it
        #if the flow is saturated
        #also, src and dst of the flow
    #For each path, we need to keep track of:
        #is the path saturated
        #allocated b/w
    
    #because we will go through the flows sequentially, it's better to have them in a list
    all_flows = [None for x in range(len(traffic))]
    
    for flow_id,(src,dst) in enumerate(traffic):
        
        if verbose:
            print("src,dst:", src,dst)
        
        temp_flow_object = {   "src" : src,
                                 "dst" : dst,
                                 "multiplier" : freq[flow_id],
                                 "saturated" : False,
                                 "path_objects" : [],
                                 "path_count" : 0,
                                 "unsaturated_path_count" : 0}
        
        temp_flow_object["path_objects"] = [None for x in range(len(path_list[(src,dst)]))]
        
        for path_id, path in enumerate(path_list[(src,dst)]):
            temp_path_object = {"path": path,
                                "saturated" : False,
                                "allocated_bw" : [] }
                    #allocated_bw is a list to hold the allocated_bw portion in each iteration.
                    #so if a link gets 0.50, 0.25 and 0.10 in three iterations, allocated_bw will be [0.50, 0.25, 0.10]
            temp_flow_object["path_objects"][path_id] = temp_path_object
            
        temp_flow_object["path_count"] = len(path_list[(src,dst)])
        temp_flow_object["unsaturated_path_count"] = temp_flow_object["path_count"]
        
        all_flows[flow_id] = temp_flow_object
    
    if verbose:
        print_flow_objects(all_flows, multiplier=True)
    
    #get initial link-usage info
    #go through each flow
        # go through each path
            #for each link, update the link-usage count
    for flow_object in all_flows:
        for path_object in flow_object["path_objects"]:
            path = path_object["path"]
            for ii in range(len(path) - 1):
                all_links[(path[ii], path[ii+1])]["usage_count"] += flow_object["multiplier"]
    
    if verbose:
        print_link_stats(all_links)


    if verbose:
        print("initialization done.")
    
    
    #each iteration has the following steps:
        # go through each path in each flow and allocate rate
        # go through each path in each flow and update link b/w and mark link saturation
        # go through each path in each flow and mark saturated paths, saturated flows, and update link usage.
    
    unsaturated_flow_count = len(all_flows)
    iteration_count = 0
    
    while unsaturated_flow_count > 0:
    #for iteration_count in range(2):
        if verbose:
            print("start iteration: ", iteration_count)
        
        #iteration will run until all the flows are saturated
        if verbose:
            print("unsaturated flow count:", unsaturated_flow_count)
            
        # go through each path in each flow and allocate rate
        for flow_object in all_flows:
            if flow_object["saturated"] == True:
                continue
            for path_object in flow_object["path_objects"]:
                if path_object["saturated"] == True:
                    continue
                path = path_object["path"]
                #print(path)
                allocated_bw = min([ all_links[path[ii], path[ii+1]]["remaining_capacity"]/all_links[path[ii], path[ii+1]]["usage_count"] for ii in range(len(path) - 1) ])
                path_object["allocated_bw"].append(allocated_bw)
                
        #    if verbose:
        #        print("\nallocated bw after initial pass:")
        #        print_flow_objects(all_flows)
    
        # go through each path in each flow and update link b/w and mark link saturation
        for flow_object in all_flows:
            if flow_object["saturated"] == True:
                continue
            for path_object in flow_object["path_objects"]:
                if path_object["saturated"] == True:
                    continue
                if len(path_object["allocated_bw"]) == iteration_count + 1:
                    #this means the path was allocated some bw in the most recent iteration,
                    #so b/w update is needed in the corresponding links.
                    #Also, iteration_count starts from 0, hence +1
                    path = path_object["path"]
                    for ii in range(len(path)-1):
                        src,dst = path[ii], path[ii+1]
                        all_links[(src,dst)]["remaining_capacity"] -= (path_object["allocated_bw"][iteration_count] * flow_object["multiplier"])
                        if all_links[(src,dst)]["remaining_capacity"] <= 0.0000001: 
                            #small enough value to be able to get around rounding error, hopefully
                            all_links[(src,dst)]["saturated"] = True
                            
        #    if verbose:
        #        print("\nupdated bw after initial pass:")
        #        print_link_stats(all_links)
        #    
        # go through each path in each flow and mark saturated paths, and update link usage.
        for flow_object in all_flows:
            if flow_object["saturated"] == True:
                continue
            for path_object in flow_object["path_objects"]:
                if path_object["saturated"] == False:
                    path = path_object["path"]
                    flag = False
                    for ii in range(len(path)-1):
                        src,dst = path[ii], path[ii+1]
                        if all_links[(src,dst)]["saturated"] == True:
                            flag = True
                            path_object["saturated"] = True
                            break
                    
                    #in case a path is saturated, it will not contribute in link_usage any more. So update.
                    if flag == True:
                        for ii in range(len(path)-1):
                            src,dst = path[ii], path[ii+1]
                            all_links[(src,dst)]["usage_count"] -= flow_object["multiplier"]
        
        # now go through the flows one last time to see which flows are saturated
        for flow_object in all_flows:
            if flow_object["saturated"] == False:
                flag = True
                for path_object in flow_object["path_objects"]:
                    if path_object["saturated"] == False:
                        flag = False
                        break
                if flag == True:
                    flow_object["saturated"] = True
                    unsaturated_flow_count -= 1
                        #another flow bites the dust
                    
        if verbose:
            print("\nFlow update after saturation tracking:")
            print_flow_objects(all_flows, multiplier=True)
                        
        if verbose:
            print("\nupdated link usage after saturation tracking:")
            print_link_stats(all_links)
        
        if verbose:
            print("end of iteration: ", iteration_count)
        
        iteration_count += 1
        
        #end of iteration loop

    #now calculate the final b/w and return as answer
    total_bw = 0.0
    for flow_object in all_flows:
        for path_object in flow_object["path_objects"]:
            total_bw += math.fsum(path_object["allocated_bw"]) * flow_object["multiplier"]
    
    res = total_bw / sum(freq)

    if verbose:
        print("total allocated bw :", total_bw)
        print("final result: ", res)
        
    if verbose:
        print("\nDone with jains ...\n")
        
    return (total_bw, res)
        
    pass

def print_link_stats(all_links):
    '''
    A simple helper function mostly useful for debugging.
    '''
    for link, properties in all_links.items():
            print(link, properties)
    print()
    pass

def print_flow_objects(all_flows, multiplier = False):
    '''
    A simple helper function mostly useful for debugging.
    '''
    print("\nflow objects: ")
    for flow_id, flow_object in enumerate(all_flows):
        print("flow_id:",flow_id)
        print("src:", flow_object["src"])
        print("dst:", flow_object["dst"])
        if multiplier:
            print("multiplier:", flow_object["multiplier"])
        print("saturated:", flow_object["saturated"])
        print("path_count:", flow_object["path_count"])
        print("unsaturated_path_count:", flow_object["unsaturated_path_count"])
        for path_object in flow_object["path_objects"]:
            print(path_object)
        print()
                
    pass





















































