import networkx as nx
import heapq
import time
import global_links_arrangment as gl
import utilites as ut
import os
import topologies as tp
import os.path
import sys

import numpy as np
import pandas as pd

from djkstra import djkstra, all_pair_all_shortest_paths_djkstra, all_pair_all_shortest_paths_networkx, gen_path, check_path_validness

from intro_code_to_test_something import draw_graph_circular

from dragonfly_minpath import generate_global_link_list_for_all_group_pairs, min_path_for_an_SD_pair, min_paths_for_all_SD_pairs, path_distribution_overall, path_distribution_analytical, different_group_nodes


#create a small test network graph
def draw_graph(G):
    '''
    G needs to be a networkX Graph object.
    Each edge has a property 'w', which is basically the weight of the edge.
    '''
    #print(G.edges(data = True))
    
    pos = nx.shell_layout(G, scale = 1)
    nx.draw(G, pos = pos , with_labels = True, node_size = 500)
    edge_labels = nx.get_edge_attributes(G,"w")
    nx.draw_networkx_edge_labels(G, pos = pos, edge_labels = edge_labels)
    pass

def draw_graph_circular_from_edgelist(edges, N, a = 4):
    G = nx.Graph()
    
    for src in range(N):
        G.add_node(src)

    for (src,dst,weight) in edges:
        G.add_edge(src,dst, weight = weight)
            
    colors = ['magenta', 'lightgreen', 'slategray','coral','cyan','red','blue','green','yellow', 'brown', 'gold', 'lightpink', ]
    
    node_colors = [colors[(x//a)%len(colors)] for x in G.nodes]
    
    options = {
        "node_color" : node_colors,
        "node_size" : 120,
        "width" : 1,
        "edge_color" : "blue",
        "with_labels": True,
        "node_size" : 400
    }

    nx.draw_circular(G, **options)
    
    #plt.show()
    pass

def draw_graph_circular(G, a = 4):
            
    colors = ['magenta', 'lightgreen', 'slategray','coral','cyan','red','blue','green','yellow', 'brown', 'gold', 'lightpink', ]
    
    node_colors = [colors[(x//a)%len(colors)] for x in G.nodes]
    
    options = {
        "node_color" : node_colors,
        "node_size" : 120,
        "width" : 1,
        "edge_color" : "blue",
        "with_labels": True,
        "node_size" : 400
    }
    
    
    nx.draw_circular(G, **options)
    
    #plt.show()
    pass

def print_graph(G):
    print("\nThe Graph:")
    all_nodes = G.nodes()
    for node in all_nodes:
        print(node, " : ", list(nx.all_neighbors(G, node)))
    pass

def intro_code():
    N = 6
    graph = [[] for x in range(N)]
    
    edges = [ (0,1,1),(0,2,1),(1,2,1), (3,4,1), (3,5,1), (4,5,1), (2,3,3), (1,5,3) ]    #(src, dest, weight)
    
    for (src,dst,weight) in edges:
        graph[src].append((dst, weight))
        graph[dst].append((src, weight))
    
    print("the graph:")
    for idx in range(len(graph)):
        print(idx, graph[idx])
    
    G = nx.Graph()
    for (src,dst,weight) in edges:
        G.add_edge(src,dst, w = weight)
    print("the graph from networkx:")
    print(G.edges(data = True))
    
    draw_graph(G)
    
    # check the paths in the graph
    #paths = djkstra(0, N, graph)
    
    #check djkstra
    
    print("\ncalling all_pair_djkstra: ")
    start_time = time.time()
    paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
    end_time = time.time()
    print("djkstra returned.")
    print("execution time: ", end_time - start_time)

    #now check floyd-warshall
    start_time = time.time()
    print("\ncalling floyd-warshall")
    paths2 = ut.floyd_warshall_all_pairs_sp(G,weight='w')
    end_time = time.time()
    print("FW returned.")
    print("execution time: ", end_time - start_time)

#    print("\nfloyd warshall paths:")
#    for src in range(N):
#        print("\nsrc:",src)
#        for dst in range(N):
#            print(src,dst, l2[src][dst])
#        

    pass


def get_path_len_stat(paths, G, config,  * , seed = 0, validity = "Valid", file_name1 = None, file_name2 = None, file_name3 = None ):
    '''
    Input: path: A 2-D array of list of tuples.
                For each S-D pair in the network, path[S][D] contains a list of tuples.
                Each tuple is a shortest path between SD.
            G: a networkx graph
            config: (a, h, g, arrg)
            
    Output: Array of dicts, containing paths of different lengths, no of paths of each len etc.
            Will detail later.
            
    '''
    
    a, h, g, arrg = config
    
    N = len(G)
    
    all_paths_stat = {}
    local_paths_stat = {}
    global_paths_stat = {}
    
    
    avg_shortest_path = nx.average_shortest_path_length(G)
    #print("average shortest path len:", avg_shortest_path)
    
    total_path_len = 0
    total_path_count = 0

    start_time = time.time()
    for src in range(N): 
        for dst in range(N):
            if src == dst:
                continue
            #print(src,dst,paths[src][dst])
            pathCount = len(paths[src][dst])
            pathLen = len(paths[src][dst][0]) - 1
            #print(src, dst, paths[src][dst], pathLen)
            
            total_path_len += pathLen
            total_path_count += 1
            
            if pathLen in all_paths_stat:
                all_paths_stat[pathLen][-1] += 1     # -1 denotes a path of any length
                                                     #so all_paths_stat[1][-1] will denote the number of total paths of len 1
                if pathCount in all_paths_stat[pathLen]:
                    all_paths_stat[pathLen][pathCount] += 1
                else:
                    all_paths_stat[pathLen][pathCount] = 1
            else:
                all_paths_stat[pathLen] = {pathCount : 1, -1 : 1}
 
            
            #if src-dst in the same group
            if src//a == dst//a:
                if pathLen in local_paths_stat:
                    local_paths_stat[pathLen][-1] += 1
                    if pathCount in local_paths_stat[pathLen]:
                        local_paths_stat[pathLen][pathCount] += 1
                    else:
                        local_paths_stat[pathLen][pathCount] = 1
                else:
                    local_paths_stat[pathLen] = {pathCount : 1, -1: 1}
                
            #src-dst in different groups
            else:
                if pathLen in global_paths_stat:
                    global_paths_stat[pathLen][-1] += 1
                    if pathCount in global_paths_stat[pathLen]:
                        global_paths_stat[pathLen][pathCount] += 1
                    else:
                        global_paths_stat[pathLen][pathCount] = 1
                else:
                    global_paths_stat[pathLen] = {pathCount : 1, -1: 1}
    
    end_time = time.time()            
    
    avg_shortest_path_manual = total_path_len / total_path_count
    #print("average shortest path len manual:", avg_shortest_path_manual)
    
    #    print("all path stat:")
    #    for length,dic in sorted(all_paths_stat.items()):
    #        print(length, sorted(dic.items()))
    #    print("local path stat:")
    #    for length,dic in sorted(local_paths_stat.items()):
    #        print(length, sorted(dic.items()))
    #    print("global path stat:")
    #    for length,dic in sorted(global_paths_stat.items()):
    #        print(length, sorted(dic.items()))
    #    #print("stat collenction time:", end_time-start_time)
    
    write_path_info_global(config, seed, validity, avg_shortest_path, avg_shortest_path_manual, global_paths_stat, file_name = file_name1)
    write_path_info_global_detailed(config,seed, global_paths_stat, file_name = file_name2)
    write_path_info_overall_detailed(config,seed, all_paths_stat, file_name = file_name3)
    
    pass

def write_path_info_global(config,seed, validity, avg_shortest_path, avg_shortest_path_manual, global_paths_stat, * , file_name = None, console_print = False):
    
    folder_name = "Path_Stats"
    os.makedirs(folder_name, exist_ok = True)
    
    a,h,g,arrg = config
    
    if file_name == None:
        file_name = folder_name + "/" + "a_{}_h{}_g{}_arrg_{}_seed_{}_global_paths.csv".format(a,h,g,arrg,seed)
    
    if not os.path.isfile(file_name):
        fp = open(file_name, "w")
        fp.write("a, ,h ,g, arrangement, seed, validity, avg_shortest_path, avg_shortest_path_manual, <pathLen, pairs with that pathLen>\n")
    else:
        fp = open(file_name, "a")
    
    if (console_print):
        print("{}, {}, {}, {}, {}, ".format(a,h,g,arrg,seed), end = "")
    fp.write("{}, {}, {}, {}, {}, ".format(a,h,g,arrg,seed))
    
    if (console_print):
        print("{}, {:6f}, {:6f}, ".format(validity, avg_shortest_path, avg_shortest_path_manual), end = ", ")
    fp.write("{}, {:6f}, {:6f}, ".format(validity, avg_shortest_path, avg_shortest_path_manual))
    
    
    for pathlen, info in sorted(global_paths_stat.items()):
        if (console_print):
            print(pathlen, ",", info[-1], end = ", ")
        fp.write(str(pathlen) + ", " + str(info[-1]) + ", ")
    if (console_print):
        print()
    fp.write("\n")
    fp.close()
    pass

def write_path_info_global_detailed(config,seed, global_paths_stat, * , file_name = None, console_print = False):
    
    folder_name = "Path_Stats"
    os.makedirs(folder_name, exist_ok = True)
    
    a,h,g,arrg = config
    
    if file_name == None:
        file_name = folder_name + "/" + "a_{}_h{}_g{}_arrg_{}_seed_{}_global_paths_detailed.csv".format(a,h,g,arrg,seed)
    
    if not os.path.isfile(file_name):
        fp = open(file_name, "w")
        fp.write("a, ,h ,g, arrangement, seed,  pathLen, <total, count of SD pairs with paths of pathLen>, <no of alternate paths, count of SD pairs with that number of alternate shortest path> \n")
    else:
        fp = open(file_name, "a")
    
    for pathlen, info in sorted(global_paths_stat.items()):
        if (console_print):
            print("{}, {}, {}, {}, {}, ".format(a,h,g,arrg,seed), end = "")
        tempstr = "{}, {}, {}, {}, {}, ".format(a,h,g,arrg,seed)
        fp.write(tempstr)
        
        if (console_print):
            print("{}, ".format(pathlen), end= "")
        tempstr = "{}, ".format(pathlen)
        fp.write(tempstr)
        
        for alt, alt_count in sorted(info.items()):
            if alt == -1:
                alt = "total"
            if (console_print):
                print("{}, {}, ".format(alt, alt_count), end= "")
            tempstr = "{}, {}, ".format(alt, alt_count)
            fp.write(tempstr)
        if (console_print):
            print()
        fp.write("\n")
    fp.close()
    pass

def write_path_info_overall_detailed(config,seed, all_paths_stat, * , file_name = None, console_print = False):
    folder_name = "Path_Stats"
    os.makedirs(folder_name, exist_ok = True)
    
    a,h,g,arrg = config
    
    if file_name == None:
        file_name = folder_name + "/" + "a_{}_h{}_g{}_arrg_{}_seed_{}_all_paths_overall.csv".format(a,h,g,arrg,seed)
    
    if not os.path.isfile(file_name):
        fp = open(file_name, "w")
        fp.write("a, ,h ,g, arrangement, seed,  pathLen, <total, count of SD pairs with paths of pathLen>, <no of alternate paths, count of SD pairs with that number of alternate shortest path> \n")
    else:
        fp = open(file_name, "a")
    
    for pathlen, info in sorted(all_paths_stat.items()):
        if (console_print):
            print("{}, {}, {}, {}, {}, ".format(a,h,g,arrg,seed), end = "")
        tempstr = "{}, {}, {}, {}, {}, ".format(a,h,g,arrg,seed)
        fp.write(tempstr)
        
        if (console_print):
            print("{}, ".format(pathlen), end= "")
        tempstr = "{}, ".format(pathlen)
        fp.write(tempstr)
        
        for alt, alt_count in sorted(info.items()):
            if alt == -1:
                alt = "total"
            if (console_print):
                print("{}, {}, ".format(alt, alt_count), end= "")
            tempstr = "{}, {}, ".format(alt, alt_count)
            fp.write(tempstr)
        if (console_print):
            print()
        fp.write("\n")
    fp.close()
    
    pass

def run_test_for_a_config(a, h, g, arrg, *, seed = 0):
    
    print("\nStarting test for: a {}, h {}, g {}, arrangment {}, seed {}".format(a,h,g,arrg,seed))
    config = (a, h, g, arrg)
    
    #folder_name = "Path_Stats"
    folder_name = "TestFolder_supposedly_unimportant_data"
    
    os.makedirs(folder_name, exist_ok = True)
    
#    file_name1 = folder_name + "/" + "a_{}_h{}_g{}_global_paths.csv".format(a,h,g)
#    file_name2 = folder_name + "/" + "a_{}_h{}_g{}_global_paths_detailed.csv".format(a,h,g)
#    file_name3 = folder_name + "/" + "a_{}_h{}_g{}_all_paths_overall.csv".format(a,h,g)
    file_name1 = folder_name + "/" + arrg + "_global_paths.csv"
    file_name2 = folder_name + "/" + arrg + "_global_paths_detailed.csv"
    file_name3 = folder_name + "/" + arrg + "_all_paths_overall.csv"

    if arrg == "practice":
        arrg = "absolute_improved"

    start_time = time.time()
    
    G, local_links, global_links = tp.build_drgonfly(a=a, p=a // 2, h=a // 2, gl_arrangmnt=arrg, g=g, seed = seed)
    end_time = time.time()
    #print("topology creation time:", end_time - start_time)
    
    if ut.validate_DF(G,global_links,local_links,a,g):
        #print("Valid topology")
        validity = "Valid"
    else:
        #print("Invalid topology")
        validity = "Invalid"
    
    #print_graph(G)
    #draw_graph_circular(G, a = a)
    
    N = len(G)
    
    #print("\ncalling all_pair_djkstra: ")
    start_time = time.time()
    paths_djk = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
    end_time = time.time()
    #print("djkstra returned.")
    #print("execution time: ", end_time - start_time)
    
    get_path_len_stat(paths_djk, G, config, seed = seed, validity = validity, file_name1 = file_name1, file_name2 = file_name2, file_name3 = file_name3)

    #    print("\ncalling all_pair_networkx: ")
    #    start_time = time.time()
    #    paths_nx = all_pair_all_shortest_paths_networkx(G, edge_weight = "w")
    #    end_time = time.time()
    #    print("netowkrx returned.")
    #    print("execution time: ", end_time - start_time)
    #    get_path_len_stat(paths_nx, G, config, seed = seed, validity = validity, file_name1 = file_name1, file_name2 = file_name2, file_name3 = file_name3)
    pass

def path_stat():
    '''
    28 Aug 2018.
    The last time we took path stats we used djkstra. 
    That causes issues in DF because we consider any path as one global 
    link as min path.
    So we want a path calculation function that will generate all the
    minimal paths for an S-D pair.
    '''
    pass

def reachability_test(Graph, a, h, g):
    '''
    We want to check, for each node, how many nodes can be reached in 1, 2 or 3 steps.
    
    Get the stat for each node individually. Then compress them to get a summary result.
    
    '''
    
    
    '''
    Logic:
        
    #call djkstra, get the table
    
    #for each pair of nodes, check the min path len. update counts for src and dst nodes accordingly.
    
    #for each node, we need to save three counts: no of nodes reachable by hops 1,2,3
    
    #when done, convert each (count_1, count_2, count_3) triplet to tuples and get their count. That is the summary we are looking for.
    '''
    
    N = len(Graph.nodes)
    
    counts = [ [0,0,0] for x in range(N) ]
    
    all_djkstra_paths = all_pair_all_shortest_paths_djkstra(Graph)
    
    for src in range(N):
        #print(src, end=" : ")
        for dst in range(src+1, N):
            #print(dst, end= " ")
            
            #don't want to consider same-group node pairs
            if different_group_nodes((src,dst), a):
                paths = all_djkstra_paths[src][dst]
                length = len(paths[0])-1 # hop count = node count  - 1
                counts[src][length-1] += 1
                counts[dst][length-1] += 1
                
    #test print
    #    for ii in range(N):
    #        print("{} : {} {} {} ".format(ii, counts[ii][0], counts[ii][1], counts[ii][2]))
    #        
    
    #get frequency
    frequency_of_reachability_count = {}
    
    for ii in range(N):
        tup = tuple(counts[ii])
        if tup in frequency_of_reachability_count:
            frequency_of_reachability_count[tup] += 1
        else:
            frequency_of_reachability_count[tup] = 1
            
    values_and_freq = []
    
    for tup,count in frequency_of_reachability_count.items():
        values_and_freq.append([a,h,g,tup[0],tup[1],tup[2], count])
        
    records = pd.DataFrame(values_and_freq)
    records.columns = ["a","h","g","dist_1","dist_2","dist_3","frequency"]
    records["dist_1_pcnt"] = records["dist_1"] / (records["dist_1"] + records["dist_2"] + records["dist_3"]) * 100
    records["dist_2_pcnt"] = records["dist_2"] / (records["dist_1"] + records["dist_2"] + records["dist_3"]) * 100
    records["dist_3_pcnt"] = records["dist_3"] / (records["dist_1"] + records["dist_2"] + records["dist_3"]) * 100
    
    #print(records)
    
    #test print
    #    print("frequency:")
    #    for row in values_and_freq:
    #        print(row)
    #     
    
    return records
        
    pass

def get_pathlength_vs_count_ratio():
    '''
    Analytically calculate the ratio of 1-hop, 2-hop and 3-hop
    long min paths over the whole network. 
    '''
    a = 4
    h = a//2
    #Gs = [2, 10, 20, 33]
    Gs = [x for x in range(2, a*h+1 + 1)]

    #topology = "practice"
    topology = "absolute_improved"
    seed = 0
    #Gs = [129]
    
    for g in Gs:
        path_distribution_analytical(a = a, g = g, h = h)
    pass

def get_node_reachablity_data():
    '''
    calculates how many nodes are reachable in 1-hop, 2-hop 
    and 3-hop long min paths from each node. 
    '''
    a = 16
    h = a//2
    #Gs = [2, 10, 20, 33]
    Gs = [x for x in range(2, a*h+1 + 1)]

    #topology = "practice"
    topology = "absolute_improved"
    seed = 0
    
    records = []
    
    for g in Gs:
        G, local_links, global_links = tp.build_drgonfly(a=a, p=a // 2, h=h, gl_arrangmnt=topology, g=g, seed = seed)
        records.append( reachability_test(G, a, h, g) )
        
    results = pd.concat(records, axis = 0, ignore_index = True)

    #print(results)
    
    folder_name = "Path_Stats/Path_Stats_2018_August"
    os.makedirs(folder_name, exist_ok = True)
    
    filename = "reachability_a_{}_g_{}.csv".format(a,g)
    
    results.to_csv(folder_name + "/" + filename, index = False)
    pass



def run_test_practice():
    a = 4
    h = a//2
    Gs = [4]
    #Gs = [x for x in range(2, a*h+1 + 1)]

    #topology = "practice"
    topology = "absolute_improved"
    seed = 0
    #Gs = [129]
    
    for g in Gs:
        start_time = time.time()
        #print("a {}, h {}, g {}".format(a,h,g) )
        #run_test_for_a_config(a, h, g, topology)
        
        #build a topology
        G, local_links, global_links = tp.build_drgonfly(a=a, p=a // 2, h=h, gl_arrangmnt=topology, g=g, seed = seed)
        
        #draw it
        draw_graph_circular(G)
        
        #get_path_stat
        #group_pair_vs_global_links_dict = generate_global_link_list_for_all_group_pairs(Graph = G, a = a)
        
        #min_path_for_an_SD_pair(src = 5, dst = 5, Graph = G, a = a, group_pair_vs_global_links_dict = group_pair_vs_global_links_dict)
        #SD_pairs_vs_paths = min_paths_for_all_SD_pairs(Graph = G, a = a, group_pair_vs_global_links_dict = group_pair_vs_global_links_dict)
        
        #path_distribution_overall(SD_pairs_vs_paths, a)
        
        #path_distribution_analytical(a = a, g = g, h = h)
        
        #print("total nodes:", len(G.nodes))
        
        reachability_test(Graph = G, a=a, h=h, g=g)
        
        end_time = time.time()
        print("total time: ", end_time - start_time)
    pass


def run_test_absolute_improved():
    a = 16
    h = 8
    #Gs = [2, 10, 20, 40, 60, 80, 100, 129]
    Gs = [x for x in range(2, a*h+1 + 1)]
    topology = "absolute_improved"
    #Gs = [129]
    
    for g in Gs:
        start_time = time.time()
        run_test_for_a_config(a, h, g, topology)
        end_time = time.time()
        print("total time: ", end_time - start_time)
    pass

def run_test_relative_improved():
    a = 16
    h = 8
    Gs = [x for x in range(2, a*h+1 + 1)]
    topology = "relative_improved"
    #Gs = [129]
    
    for g in Gs:
        start_time = time.time()
        run_test_for_a_config(a, h, g, topology)
        end_time = time.time()
        print("total time: ", end_time - start_time)
    pass
    
def run_test_random():
    a = 16
    h = 8
    Gs = [2, 10, 20, 40, 60, 80, 100, 129]
    seeds = [x for x in range(100)]
    topology = "random"
    #Gs = [129]
    
    for g in Gs:
        for seed in seeds:
            start_time = time.time()
            run_test_for_a_config(a, h, g, topology, seed = seed)
            end_time = time.time()
            print("total time: ", end_time - start_time)
    pass


def run_test_greedy_random():
    a = 16
    h = 8
    Gs = [2, 10, 20, 40, 60, 80, 100, 129]
    seeds = [x for x in range(100)]
    topology = "greedy_random"
    #Gs = [129]
    
    for g in Gs:
        for seed in seeds:
            start_time = time.time()
            run_test_for_a_config(a, h, g, topology, seed = seed)
            end_time = time.time()
            print("total time: ", end_time - start_time)
    pass


def run_test_leftover_greedy_random1():
    a = 16
    h = 8
    Gs = [2, 10, 20, 40, 60, 80, 100, 129]
    seeds = [x for x in range(100)]
    topology = "leftover_greedy_random1"
    #Gs = [129]
    
    for g in Gs:
        for seed in seeds:
            start_time = time.time()
            run_test_for_a_config(a, h, g, topology, seed = seed)
            end_time = time.time()
            print("total time: ", end_time - start_time)
    pass


def run_test_leftover_greedy_random2():
    a = 16
    h = 8
    Gs = [2, 10, 20, 40, 60, 80, 100, 129]
    seeds = [x for x in range(100)]
    topology = "leftover_greedy_random2"
    #Gs = [129]
    
    for g in Gs:
        for seed in seeds:
            start_time = time.time()
            run_test_for_a_config(a, h, g, topology, seed = seed)
            end_time = time.time()
            print("total time: ", end_time - start_time)
    pass

def run_test(choice):
        
        # 1: absolute_improved
        # 2: relative_improved
        # 3: random
        # 4: greedy_random
        # 5: leftover_greedy_random1
        # 6: leftover_greedy_random2
    if choice == 0:
        run_test_practice()
    elif choice == 1:
        run_test_absolute_improved()
    elif choice == 2:
        run_test_relative_improved()
    elif choice == 3:
        run_test_random()
    elif choice == 4:
        run_test_greedy_random()
    elif choice == 5:
        run_test_leftover_greedy_random1()
    elif choice == 6:
        run_test_leftover_greedy_random2()
    else:
        print("Invalid choice: ", choice)
    
    pass
    
if __name__ == "__main__":
    print("Hello World!")
    
    #    if len(sys.argv) < 2:
    #        print("usage: python3 -u djkstra.py case")
    #        sys.exit(1) 
    #    
    #    case = int(sys.argv[1])
    #
    case = 0
    #run_test_practice()    
    #run_test(case)
    #intro_code()
    get_node_reachablity_data()
    print("The world never says hello back.")
    

