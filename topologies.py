#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Mar  8 16:19:06 2018

@author: Zaid and Gene
"""


import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import argparse
from networkx.drawing.nx_agraph import graphviz_layout, to_agraph
import math
import global_links_arrangment as gl
import random
import copy
'''
topologies supported 
-  torus
- de brujin
- dragonfly
- jelyfish
- slimfly

'''
def build_de_brujin(n,r):

    G = nx.DiGraph()

    for x in range(n):
        for y in range(r):
            other_end = (x*r+y)%n
            #print(x ,"->> ",other_end)
            G.add_edge(x,other_end ,arrowsize=2.0)

    return G


def build_torus(N):

    G = nx.Graph()
    edgs_list = list()
    ncols = 8 # Number of columns in a 10x10 grid of positions
    plt.gca().invert_yaxis()

    y = 0
    z = 0
    for x in range((N**2),2*(N**2)):

        if not x % N:
            y += 70
            z = 0
        G.add_node(x, pos=(N**4 + z , N**4 + y))
        z +=70


    for x in range(N):
        G.add_edge((N * N) + x, (2*(N * N)) - N + x,r=0 ,key =str((N * N) + x)+ str((2*(N * N)) - N + x))
        k = str((N * N) + x)+ str((2*(N * N)) - N + x)
       # edgs_list[k]=0

    for x in range(N-1):
        k = str((N * N) + x)+str((N * N) + x)
        #edgs_list[k]=0
        G.add_edge((N * N) + x, (N * N) + x + 1, r=0 , key = str((N * N) + x)+str((N * N) + x))

        k = str(2*(N * N) + x - N)+str(2*(N * N) + x + 1 - N)
        #edgs_list[k]=0
        G.add_edge(2*(N * N) + x - N, 2*(N * N) + x + 1 - N, r=0 ,key = str(2*(N * N) + x - N)+str(2*(N * N) + x + 1 - N))

    for x in range((N**2),(2*(N**2)-N),N):

        k = str(x)+str(x + N)
        #edgs_list[k]=0
        G.add_edge(x, x + N, r=0,key = str(x)+str(x + N))

        k = str(x + N-1)+str(x + (2 * N)-1)
        #edgs_list[k]=0
        G.add_edge(x + N-1, x + (2 * N)-1, r=0,key = str(x + N-1)+str(x + (2 * N)-1))

    for x in range(N):
        k = str((N*N)+(x*N))+str(((N*N)+(x*N)) + N - 1)
        #edgs_list[k]=0
        G.add_edge((N*N)+(x*N) ,((N*N)+(x*N)) + N - 1,r=0,key = str((N*N)+(x*N))+str(((N*N)+(x*N)) + N - 1))


    z = 1
    for x in range(((N*N)+N+1),(2*(N**2))-N):
        if z!=0 and z!= N-1 :
            k = str(x)+str(x-1)
            #edgs_list[k] = 0
            G.add_edge(x, x-1,r=0,key = str(x)+str(x-1))
            #print(x-1)
            k = str(x)+str(x + 1)
            #edgs_list[k] = 0
            G.add_edge(x, x + 1,r=0,key = str(x)+str(x + 1))
            #print(x + 1)
            k = str(x)+str(x - N)
            #edgs_list[k] = 0
            G.add_edge(x, x - N,r=0,key = str(x)+str(x - N))
            #print(x - N)
            k = str(x)+str(x + N)
            #edgs_list[k] = 0
            G.add_edge(x, x + N,r=0,key = str(x)+str(x + N))
           # print(x + N)
            z +=1
        if not x % N :
            z = 1

    return G

'''
global links arrangments for the global links 
'''


def arrang_global_link_smart(G, g, a, h, name, seed = 0):
    
    s_d_list = gl.global_links_arrangment(name, a, g, h, seed)
    
    if not s_d_list:
        return G ,[]        
    global_links = {}
    #     print(name)

    for (switch, connect_to) in s_d_list:

        if (switch, connect_to) in global_links or (connect_to, switch) in global_links:
            continue

        t1 = s_d_list.count((switch, connect_to))
        t2 = s_d_list.count((connect_to, switch))

        max_w = max(t1, t2)

        for link in [(switch, connect_to), (connect_to, switch)]:
            global_links[link] = dict()
            global_links[link]['width'] = max_w  # G[switch][connect_to]['wight']
            global_links[link]['load'] = 0
            global_links[link]['count'] = 0
            global_links[link]['weight'] = 3    #weight: global 3 local 1
            
        
        G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, cap=max_w,
                   dire={(switch, connect_to): 1})

    return G, global_links


def build_drgonfly_groups(a, p, h, g):
    # g (number of groups in the system)
    # a (number of routers in each group)
    # p (number of servers connected to each router)
    # h (number of glbal links from a switch)
    local_links = {}
    '''
    create intera-group connections 
    '''
    G = nx.Graph()
    swtchs_ids = list(range(g * a))
    # print(swtchs_ids)
    for sub_group in range(g):
        # print(swtchs_ids[sub_group * a:((sub_group + 1) * a)])
        sub_G = nx.complete_graph(swtchs_ids[sub_group * a:((sub_group + 1) * a)])
        G = nx.compose(G, sub_G)

    labels = 'local'
    color = (0.0, 0.0, 0.0)
    w = 1
    cap = 1
    dire = dict()

    nx.set_edge_attributes(G, labels, 'type')
    nx.set_edge_attributes(G, color, 'color')
    nx.set_edge_attributes(G, w, 'w')
    nx.set_edge_attributes(G, dire, 'dire')
    nx.set_edge_attributes(G, cap, 'cap')
    
    for u, v in list(G.edges()):
        G[u][v]['dire'] = {(u, v): 1}
        local_links[(u, v)] = dict()
        local_links[(u, v)]['width'] = 1
        local_links[(u, v)]['load'] = 0
        local_links[(u, v)]['count'] = 0
        local_links[(u,v)]['weight'] = 1    #weight: global 3 local 1
            
        G[u][v]['dire'][(v, u)] = 1
        local_links[(v, u)] = dict()
        local_links[(v, u)]['width'] = 1
        local_links[(v, u)]['load'] = 0
        local_links[(v, u)]['count'] = 0
        local_links[(v, u)]['weight'] = 1    #weight: global 3 local 1
        
    return G, local_links


'''
Dragonfly topology
'''


def build_drgonfly(a, p, h, gl_arrangmnt, g=None, seed = 0):
    if not g:
        g = a * h + 1

    G, local_links = build_drgonfly_groups(a, p, h, g=g)
    
    '''
    create inter-group connections 
    '''

    # G = arrange_global_link(G , g , a , h ,gl_arrangmnt)
    G, global_links = arrang_global_link_smart(G, g, a, h, gl_arrangmnt, seed)
    #    print(
    #        "Topology name : Dragonfly ({})\nNumber of Groups:{}\nNnumber of links: {}\nNnumber of Swithes: {}\nSwitch per Group:{}\n".format(
    #            gl_arrangmnt, g, G.number_of_edges(), G.number_of_nodes(), a))
    return G, local_links, global_links

'''
jellyfish topology
'''
def build_jellyfish(n,r):

    node_set_1 = np.arange(n)
    node_set_2 = np.arange(n)

    np.random.shuffle(node_set_1)
    np.random.shuffle(node_set_2)
    #print(node_set_1,'\n',node_set_2)
    adj_mx = np.zeros(shape=(n,n))

    links_count = 0

    while links_count < (n*r)/2 :

        for node1 in node_set_1:

            for node2 in node_set_2:

                if np.sum(adj_mx, axis=0)[node1] == r:
                    break

                if adj_mx[node1,node2]:
                    continue

                if node1 == node2 :
                    continue

                if np.sum(adj_mx, axis=0)[node2] == r:
                    continue

                adj_mx[node1 ,node2] = 1
                adj_mx[node2, node1] = 1
                #print(node1 ," --> ",node2)
                links_count += 1


            #remove link and replace it with a connection to the new node
            while np.sum(adj_mx, axis=0)[node1] < r:

                while True :
                    rand_node1 = np.random.random_integers(0, n-1)
                    rand_node2 = np.random.random_integers(0, n-1)
                    #print(rand_node1 ,rand_node2)

                    if rand_node1 != rand_node2 and\
                       rand_node1 != node1 and\
                       rand_node2 != node1 and\
                       not adj_mx[node1,rand_node1] and \
                       not adj_mx[node1, rand_node2] and \
                       adj_mx[rand_node1,rand_node2] :

                       break

                # replace links

                adj_mx[rand_node1 , rand_node2] = 0
                adj_mx[rand_node2, rand_node1] = 0

                adj_mx[node1 , rand_node2] = 1
                adj_mx[rand_node2, node1] = 1
                links_count += 1

                adj_mx[rand_node1 , node1] = 1
                adj_mx[node1, rand_node1] = 1
                links_count += 1



    G = nx.from_numpy_matrix(adj_mx)

    return G

'''
smart jellyfish topology
'''
def build_jellyfish2(n,d):
    G = nx.complete_graph(d+1)
    cNodes = d+1
    prev = -1
    while cNodes < n:
        nodes = list(G.nodes())
        random.shuffle(nodes)
        nodesI = {y:x for x, y in list(enumerate(nodes))}
        nodes = {x:y for x, y in list(enumerate(nodes))}
        if prev != -1:
            nodes.pop(nodesI[prev])
            G.add_edge(prev, cNodes)
            prev = -1
        G.add_node(cNodes)
        while nx.degree(G, cNodes) < d:
            node = nodes.popitem()[1]
            neighbors = list(nx.neighbors(G,node))
            random.shuffle(neighbors)
            while True:
                end = neighbors.pop()
                if end in nodes.values():
                    break
            nodes.pop(nodesI[end])
            G.remove_edge(node,end)
            G.add_edge(node, cNodes)
            if nx.degree(G, cNodes) == d:
                prev = end
                break
            else:
                G.add_edge(end, cNodes)
        cNodes += 1
    #print(G.number_of_edges())
    #print([nx.degree(G, n) for n in G.nodes()])
    #plt.show()
    return G


'''
smart jellyfish topology
'''


def build_smart_jellyfish(n, d, s):
    G = nx.complete_graph(d + 1)
    cNodes = d + 1
    prev = -1
    while cNodes < n:
        nodes = list(G.nodes())
        random.shuffle(nodes)
        nodesI = {y: x for x, y in list(enumerate(nodes))}
        nodes = {x: y for x, y in list(enumerate(nodes))}
        if prev != -1:
            nodes.pop(nodesI[prev])
            G.add_edge(prev, cNodes)
            prev = -1
        G.add_node(cNodes)

        best = n * d
        best_G = None
        best_prev = None
        for _ in range(s):
            prev_tmp = prev
            G_tmp = copy.deepcopy(G)
            nodes_tmp = copy.deepcopy(nodes)

            while nx.degree(G_tmp, cNodes) < d:
                node = nodes_tmp.popitem()[1]
                neighbors = list(nx.neighbors(G_tmp, node))
                random.shuffle(neighbors)
                while True:
                    end = neighbors.pop()
                    if end in nodes_tmp.values():
                        break
                nodes_tmp.pop(nodesI[end])
                G_tmp.remove_edge(node, end)
                G_tmp.add_edge(node, cNodes)
                if nx.degree(G_tmp, cNodes) == d:
                    prev_tmp = end
                    break
                else:
                    G_tmp.add_edge(end, cNodes)

            temp_best = nx.average_shortest_path_length(G_tmp)

            if temp_best < best or best_G is None:
                best = temp_best
                best_G = G_tmp
                best_prev = prev_tmp

        G = best_G
        prev = best_prev

        cNodes += 1
    # print(G.number_of_edges())
    # print([nx.degree(G, n) for n in G.nodes()])
    return G
def draw_DF_graphs(G, a, i, arrgs,x):
    i = i + 1
    # labels = dict((i, i%a) for i in G.nodes())
    labels = dict((i, str(i % a) + " , " + str(i)) for i in G.nodes())
    colors = [G[u][v]['color'] for u, v in G.edges()]

    options = {
        'node_color': 'red',
        'node_size': 120,
        'width': 1,
        'labels': labels,
        'edge_color': colors,
    }

    plt.subplot(math.ceil(x/2), 2, i)
    plt.title(arrgs)
    nx.draw_circular(G, **options)


def draw_DF_a_graph(G, a, arrgs):
    # labels = dict((i, i%a) for i in G.nodes())
    labels = dict((i , i) for i in G.nodes())#dict(("("+str(i//a)+","+str(i % a) + "), " + str(i)) for i in G.nodes())
    colors = [G[u][v]['color'] for u, v in G.edges()]

    options = {
        'node_color': 'red',
        'node_size': 120,
        'width': 1,
        'labels': labels,
        'edge_color': colors,
    }

    plt.title(arrgs)
    nx.draw_circular(G, **options)
    plt.show()


def draw_DF_a_graph_wo_colors(G, a, arrgs):
    # labels = dict((i, i%a) for i in G.nodes())
    labels = dict((i , i) for i in G.nodes())#dict(("("+str(i//a)+","+str(i % a) + "), " + str(i)) for i in G.nodes())

    options = {
        'node_color': 'red',
        'node_size': 120,
        'width': 1,
        'labels': labels,
    }

    plt.title(arrgs)
    nx.draw_circular(G, **options)
    plt.show()
def drow_torus(N,G):


    #pos = graphviz_layout(G, prog='dot')#,
    pos = nx.get_node_attributes(G, 'pos')

    nx.draw_networkx_nodes(G,pos=nx.get_node_attributes(G, 'pos'),node_size=1000/N)
    pos = nx.get_node_attributes(G, 'pos')

    edge_labels = nx.get_edge_attributes(G, 'r')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels )

    # edges
    nx.draw_networkx_edges(G,pos,width=2)

    # labels
    nx.draw_networkx_labels(G,pos,font_size=50/N,font_family='sans-serif')

    plt.axis('off')
    #plt.savefig('../used_edges_dimorder10.png')
    #plt.savefig('../used_edges_dimorder10.pdf')
    plt.show()

'''
plot the topology
'''
def draw_graph(G , name ,a = None):
    labels = dict((i, i) for i in G.nodes())

    pos = nx.spectral_layout(G)

    nx.draw_networkx_nodes(G, pos ,
                           nodelist=list(G.nodes()),
                           node_color='r',
                           node_size=500,
                           alpha=0.8)
    nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)

    labels = dict((i, i) for i in G.nodes())
    plt.title(name)
    nx.draw_networkx_labels(G, pos, labels, font_size=16)
    plt.show()


def set_edge_weight(G,w):
    nx.set_edge_attributes(G, w , 'wight')

    return G


def add_process_to_a_graph(G,p):
   
    newG = nx.Graph()
    n = G.number_of_nodes()
    N = n * p + n
    ofset =  n * p  
    
    for s,d in G.edges():
        newG.add_edge(s+ofset , d + ofset)
    
    sw = ofset    
    for n in range(ofset):
        newG.add_edge(n , sw)
        if n % p == 0:
            sw += 1
            
    return newG    
         
def add_processes_to_a_graph(G,p):
   
    n = G.number_of_nodes()
    N = n * p + n 
    #ofset =  n * p  
    
    type = 'g'
    nx.set_node_attributes(G, type, 'type')
    #draw_DF_a_graph_wo_colors(G,a,'DF')
    G.add_nodes_from(list(range(n,N)),type='l')
    proc_id = n

    for node in range(n):
        for p_id in range(p):
            #print(proc_id,p_id)
            #print(node,proc_id ,"\n")
            G.add_edge(node , proc_id,color='red')
            proc_id += 1
    #draw_DF_a_graph_wo_colors(G,a,'DF')    
    #return newG      
#G = build_drgonfly(4,2,2,'absolute_improved',3)[0]
#add_processes_to_a_graph(G,2)
# draw_DF_a_graph(G,4,'random')
# = build_torus(8)
#drow_torus(8,G)

# G = build_jellyfish(8,2)
#
# draw_graph(G,'jellifish1',G.number_of_nodes())
#
# G = build_jellyfish2(8,2)
# draw_graph(G,'jellifish2',G.number_of_nodes())
#
# G = build_smart_jellyfish(8,2,100)
# draw_graph(G,'jellifish3',G.number_of_nodes())