'''
28 Aug 2018.
The last time we took path stats we used djkstra. 
That causes issues in DF because we consider any path as one global 
link as min path.
So we want a path calculation function that will generate all the
minimal paths for an S-D pair.

For DF: a min path is defined as (local hop) + global hop + (local hop)
'''

def generate_global_link_list_for_all_group_pairs(Graph, a):
    '''
    For each src_group and dst_group pairs, get a list of all the global links that foes through them.
    '''
    
    group_pair_vs_global_links_dict = {}
    
    #go through each link in the graph
    #print("printing all links:")
    for idx,edge in enumerate(Graph.edges(data = True)):
        #print(idx, " : " , edge)
        
        src = edge[0]
        dst = edge[1]
        type = edge[2]["type"]
        
        src_group = src // a
        dst_group = dst // a
        
        if dst_group < src_group:
            #swap src_group and dst_group
            temp = src_group
            src_group = dst_group
            dst_group = temp
        
        #print(src,dst,type,src_group, dst_group)
        
        if type == "global":
            #add it to the dict
            if (src_group, dst_group) not in group_pair_vs_global_links_dict:
                group_pair_vs_global_links_dict[(src_group, dst_group)] = [edge]
            else:
                group_pair_vs_global_links_dict[(src_group, dst_group)].append(edge)
                
        
    #test print
    #    count = 0
    #    for pair, links in group_pair_vs_global_links_dict.items():
    #        print("\npair:",pair)
    #        for link in links:
    #            print("    ",count," : ",link)
    #            count += 1
    #    
    return group_pair_vs_global_links_dict

    pass

def min_path_for_an_SD_pair(src, dst, Graph, a, group_pair_vs_global_links_dict):
    '''
    As the name suggests, get min path for a single pair src and dst.
    
    Min path is defined as (local hop) + global hop + (local hop)

    '''
    
    paths = []
    
    #handle invalid case
    if src == dst:
        return paths
    
    #get src group and dst group
    src_group = src // a
    dst_group = dst // a
    
    #if src and dst are in the same group
    if src_group == dst_group:
        paths = [(src,dst)]
    
    #else, get global paths
    #lookup the global links
    if src_group < dst_group:
        global_links = group_pair_vs_global_links_dict[(src_group, dst_group)]
    
        #for each global link, generate a path 
        for link in global_links:
            #print(link)
            src_gateway = link[0]
            dst_gateway = link[1]
            if src == src_gateway and dst == dst_gateway:
                path = (src,dst)
            elif src == src_gateway:
                path = (src, dst_gateway, dst)
            elif dst == dst_gateway:
                path = (src, src_gateway, dst)
            else:
                path = (src, src_gateway, dst_gateway, dst)
            
            paths.append(path)
            
    if src_group > dst_group:
        global_links = group_pair_vs_global_links_dict[(dst_group, src_group)]
    
        #for each global link, generate a path 
        for link in global_links:
            #print(link)
            src_gateway = link[1]
            dst_gateway = link[0]
            if src == src_gateway and dst == dst_gateway:
                path = (src,dst)
            elif src == src_gateway:
                path = (src, dst_gateway, dst)
            elif dst == dst_gateway:
                path = (src, src_gateway, dst)
            else:
                path = (src, src_gateway, dst_gateway, dst)
            
            paths.append(path)
        
            
    #test print
    #    for path in paths:
    #        print(path)
    #        
    return paths

    pass

def min_paths_for_all_SD_pairs(Graph, a, group_pair_vs_global_links_dict):
    '''
    Use the min_path_for_an_SD_pair() function for each SD pair
    '''
    
    SD_pairs_vs_paths = {}
        #key: tuple of SD pair
        #value: list of tuples. Each tuple is a path.
    
    N = len(Graph.nodes)
    
    for src in range(N):
        for dst in range(N):
            if src == dst:
                continue
            paths = min_path_for_an_SD_pair(src,dst,Graph,a,group_pair_vs_global_links_dict)
            SD_pairs_vs_paths[(src,dst)] = paths
    
    #test print
    #    for tup, paths in SD_pairs_vs_paths.items():
    #        if differnet_group_nodes(tup,a):
    #            print(tup)
    #            for path in paths:
    #                print("    ", path)
    #        
    return SD_pairs_vs_paths
        
    pass


def different_group_nodes(pair,a):
    '''
    Gets an SD tuple.
    returns True if they are in different groups
    '''
    if pair[0]//a == pair[1]//a:
        return False
    else:
        return True
    pass

def path_distribution_overall(SD_pairs_vs_paths,a):
    '''
    For all SD pairs, we get all the paths.
    Then we take count of the paths of each length.
    
    SD_pairs_vs_paths:
        a dict where
            key: tuple of SD pair
            value: list of tuples. Each tuple is a path.
    
    '''
    
    pathlen_vs_count = {}
    
    #initialize. We only have 3 length options for min path.
    pathlen_vs_count[1] = 0
    pathlen_vs_count[2] = 0
    pathlen_vs_count[3] = 0
    
    for tup,paths in SD_pairs_vs_paths.items():
        if different_group_nodes(tup,a):
            for path in paths:
                pathlen_vs_count[len(path)-1] += 1
                    # -1 because hop count = node count - 1
        
    #test print
    print("path distribution:")
    #for length in range(1,4):
    #    print(length, " : ", pathlen_vs_count[length])
    print(pathlen_vs_count[1], pathlen_vs_count[2], pathlen_vs_count[3])
    
    return pathlen_vs_count
    
    pass

def path_distribution_analytical(a,g,h):
    N = a * g
    pathlen_1 = N * h
    pathlen_2 = N * 2 * h * (a-1)
    pathlen_3 = N * (a-1) * (a-1) * h
    total_path = pathlen_1 + pathlen_2 + pathlen_3
    pathlen1_pcnt = pathlen_1/total_path*100
    pathlen2_pcnt = pathlen_2/total_path*100
    pathlen3_pcnt = pathlen_3/total_path*100
    
    #test print
    #print("path distribution (analytically): ")
    #    print(1, " : ", pathlen_1)
    #    print(2, " : ", pathlen_2)
    #    print(3, " : ", pathlen_3)
    #print(pathlen_1, pathlen_2, pathlen_3)
    print("{} , {} , {}, {} , {} , {} , {:.2f} , {:.2f} , {:.2f}".format(a,h,g,pathlen_1, pathlen_2, pathlen_3,pathlen1_pcnt, pathlen2_pcnt, pathlen3_pcnt))
    
    return (pathlen_1, pathlen_2, pathlen_3)
















