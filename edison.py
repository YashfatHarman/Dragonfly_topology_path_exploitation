#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 14 15:30:40 2018

@author: rahman
"""
import re
import networkx as nx
import sys
import random

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

def create_edison_group(graph, group):
    '''
    An edison group contains 6 rows and 16 columns.
    Each node in a column is fully connected with each other with 1 link.
    Each node in a row is connected to the same-column element in five other rows. 
    
    Data structure:
        graph: a 2-D list of tuples. Each tuple has 3 elements: (dest_id, no_of_links, weight_of_link)
        
            weight_of_link: local 1, global 3
    '''
    
    
    for y in range(dims[1]):
        for x in range(dims[0]):
            src = group * _a +  y*dims[0] + x
            
            #connect src to all other nodes in the same row
            dsts = [dst for dst in range(group * _a + y*dims[0], group * _a + (y+1)*dims[0]) if dst != src]
            graph[src] = [(dst, 1, 1) for dst in dsts]
            
            #now connect all the nodes in different row but same columns
            dsts = [group * _a + ii*dims[0]+x for ii in range(dims[1]) if (group * _a + ii*dims[0]+x) != src ]
            tmp_list = [(dst,3,1) for dst in dsts]
            graph[src].extend(tmp_list)

            
    pass

def connect_all_groups(graph):
    
    for group in range(_g):
        create_edison_group(graph, group)
    
    pass

def connect_global_connections(graph, filename = "edison_globallinks.txt"):
    '''
    read connections from a file and connect the graph.
    
    Example line:
        c7-3c1s7a0l12(15:4:7) blue -> c7-2c1s11a0l04(11:4:11)
        
        The first (15:4:7) is the (src_group, chassis, slot)
        The second (11:4:11) is the (dst_group, chassis, slot)
        
        Each link here is uni-drectional.
        We can assume that there will be a opposite-direction counterpart for each link.
    
    regex might be the best option to extract the required lines.
    '''
    
    global global_links_between_groups
    
    pattern = r"c\d+-\d+c\d+s\d+a\d+l\d+\(\d+:\d+:\d+\)\s+\D+\s+->\s+c\d+-\d+c\d+s\d+a\d+l\d+\(\d+:\d+:\d+\)"
                    #               quick refresher: 
                    #                    \d -> any digit
                    #                    \D -> any character except digit
                    #                    \s -> any whitespace character
                    #                    + -> one or more occurance
                    #                    ( and ) needs to be escaped with \ 
    pattern2 = r"\d+:\d+:\d+"
        
    p = re.compile(pattern)
    p2 = re.compile(pattern2)
    
    global_link_count = 0
    
    global_link_cache = [{} for x in range(_nTOR)]
    
    fp = open(filename, "r")
    for line in fp:
        if p.match(line) != None:
            #print("MATCH****************")
            #print(line)
            global_link_count += 1
            triplets = p2.findall(line)
            src_triplet = [int(x) for x in triplets[0].split(":")]
            dst_triplet = [int(x) for x in triplets[1].split(":")]
            src_group, src_chassis, src_slot =  src_triplet
            dst_group, dst_chassis, dst_slot =  dst_triplet
            #print(src_group, src_chassis, src_slot)
            #print(dst_group, dst_chassis, dst_slot)
            
            if src_group >= 13: #group 12 does not exist
                src_group -= 1
            if dst_group >= 13:
                dst_group -= 1
            
            src_node = src_group * dims[0] * dims[1] + src_chassis * dims[0] + src_slot
            dst_node = dst_group * dims[0] * dims[1] + dst_chassis * dims[0] + dst_slot
            
            #print(src_node, dst_node)
            
            #enter it into the cache
            if dst_node not in global_link_cache[src_node]:
                global_link_cache[src_node][dst_node] = 1
            else:
                global_link_cache[src_node][dst_node] += 1
                
            #update the global  global_links_between_groups cache
            if (src_group, dst_group) in global_links_between_groups:
                global_links_between_groups[(src_group, dst_group)].append((src_node, dst_node))
            else:
                global_links_between_groups[(src_group, dst_group)] = [(src_node, dst_node)]
                
    fp.close()
    
    #now go through the cache and add the links intot he graph
    for src_node in range(_nTOR):
        #print(src_node, " -> ", list(global_link_cache[src_node].items()))
        for dst_node, freq in sorted(global_link_cache[src_node].items()):
            graph[src_node].append((dst_node, freq, 3))
    
    #print("total global links: ", global_link_count)
    pass


def generate_nx_graph(graph):
    
    G = nx.Graph()
    
    for src in range(len(graph)):
        for (dst,freq,weight) in graph[src]:
            if not G.has_edge(src,dst):
                G.add_edge(src,dst, weight = weight, cap = freq)
                
    print("Graph created.")
    print("total nodes: ", len(G.nodes))
    print("total edges: ", len(G.edges))
    
    return G 

    pass

def lay_down_an_edison_group(group):
    '''
    Because Edison is too big to visualize properly, lets just lay out a group as a grid.
    '''
    
    print("Group: ", group)
    for y in range(dims[1]):
        for x in range(dims[0]):
            src = group * _a +  y*dims[0] + x
            print("{:6d}".format(src), end = "")
        print()
            
    pass

def list_all_outgoing_links_from_a_node(src):
    
    print("node ", src, end = " -> ")
    
    for idx in range(len(graph[src])):
        tupl = graph[src][idx]
        print(tupl, end= ",")
    print()
    pass

def validate_path_between_nodes(src,dst, G, graph):
    src_group = src//(dims[0]*dims[1])
    dst_group = dst//(dims[0]*dims[1])
    #print(src,src_group)
    #print(dst,dst_group)
    lay_down_an_edison_group(src_group)
    lay_down_an_edison_group(dst_group)
    
    paths = nx.all_shortest_paths(G, src, dst, weight = "weight")
    
    for path in paths:
        print(path)
        #        for node in path:
        #            neighbors = graph[node]
        #            print("{:4d}".format(node), end = " : ")
        #            for dest,weight,cap in neighbors:
        #                print(dest, end = ",")
        #            print()

    print("available global links: ")
    global_links = global_links_between_groups[(src_group, dst_group)]
    for link in global_links:
        print(link)

#    #neighbors of node 0 from graph data structure
#    node= 0
#    neighbors = graph[node]
#    print("{:4d}".format(node), end = " : ")
#    for dest,weight,cap in neighbors:
#        print(dest, end = ",")
#    print()
#    
#    #neighbors of node 0 from networkx graph
#    node = 0
#    print("{:4d}".format(node), end = " : ")
#    neighbors = nx.all_neighbors(G, node)
#    for neighbor in neighbors:
#        print(neighbor, end = ",")
#    print()
#    

def create_graph():
    N = 4
    #graph = [[] for x in range(N)]
    
    edges = [ (0,1,1),(1,2,1),(2,3,1), (3,0,1), ]    #(src, dest, weight)
    
    #    for (src,dst,weight) in edges:
    #        graph[src].append((dst, weight))
    #        graph[dst].append((src, weight))
    #    
    #    print("the graph:")
    #    for idx in range(len(graph)):
    #        print(idx, graph[idx])
    #
    
    G = nx.Graph()
    for (src,dst,weight) in edges:
        G.add_edge(src,dst, weight = weight, cap = 1)
    
    print("the graph from networkx:")
    print(G.edges(data = True))
    
    #    print(G.has_edge(0,1))
    #    print(G.has_edge(1,0))
    #    print(G.has_edge(1,3))
    #    
    draw_graph_circular(G)
    paths = nx.all_shortest_paths(G, 0, 2, "weight")
    for path in paths:
        print(path)
    
    return G
    
    pass

def draw_graph_circular(G, a = 1, *, edge_label = False):
            
    colors = ['green', 'red','cyan','blue','yellow','magenta', 'lightgreen', 'slategray','coral', 'brown', 'gold', 'lightpink', ]
    node_colors = [colors[(x//a)%len(colors)] for x in G.nodes]
    
    edge_colors = [colors[edge[2]["weight"]] for edge in G.edges(data=True)]
    
    options = {
        "node_color" : node_colors,
        "width" : 1,
        "edge_color" : edge_colors,
        "with_labels": True,
        "node_size" : 600
    }
    
    
    #nx.draw_circular(G, **options)
    pos = nx.circular_layout(G) 
    
    nx.draw(G, pos = pos , **options)
    
    if edge_label:
        edge_labels = nx.get_edge_attributes(G,"weight")
        nx.draw_networkx_edge_labels(G, pos = pos, edge_labels = edge_labels)
    
    #plt.show()
    pass


def visualize_global_links(G):
    #global global_links_between_groups
    
    #first get the number of links between each pair of groups
    #it might be that two links are flowing through exact same pair of nodes, but it is okay
    group_pair_link_count = [ [0 for x in range(_g)] for y in range(_g) ]
    
    for src in range(_g):
        for dst in range(_g):
            if src != dst:
                group_pair_link_count[src][dst] = len(global_links_between_groups[(src,dst)])
    
    #    for row in group_pair_link_count:
    #        print(row)
    #        
    ax = sns.heatmap(group_pair_link_count, annot = True)
        #so each group pair has 24 global links between them
    plt.show()
    
    #is there any global s-d pair that has a capacity of larger than two?
    links = G.edges(data = True)
    count_unique = 0
    count_total = 0
    for link in links:
        if link[2]["weight"] == 3:
            count_unique += 1
            count_total += link[2]["cap"]
    print("total unique globals: ", count_unique)
                        #1260
    print("total global links: ", count_total)
                        #2520
                        
    #    '''
    #    Total group pairs: 15*14 = 210
    #    24 unidirectional links between each groups: 210 * 24 = 5040
    #    
    #    total unique bidirectional global links: 1260
    #    total bidirectional global links: 2520 = 1260 * 2
    #    total unidirectional global links: 5040 = 2520 * 2
    #    
    #    So from each group, there are 24 outgoing links to each other groups, paired in 2. 
    #    So total 12 pairs outgoing nodes to each other group.
    #    
    #    So from each group, there are total 24 * 14 = 336 outgoing links = 168 pairs
    #    
    #    So total outgoing links in the network: 336 * 15 = 5040
    #    
    #    '''
    #    
    
    #lets have a look at node-degree
    total_node_degree = [0 for x in range(_nTOR)]
    global_node_degree = [0 for x in range(_nTOR)]
    local_node_degree = [0 for x in range(_nTOR)]
    
    for src,neighbors in enumerate(graph):
        total_c = 0
        local_c = 0
        global_c = 0      
        #print(neighbors)
        for (dst,cap,weight) in neighbors:
            total_c += cap
            if weight == 1:
                local_c += cap
            if weight == 3:
                global_c += cap
                
        total_node_degree[src] = total_c
        local_node_degree[src] = local_c
        global_node_degree[src] = global_c
        
    ax = sns.countplot(total_node_degree)
    plt.show()
    
    ax = sns.countplot(local_node_degree)
    plt.show()
    
    ax = sns.countplot(global_node_degree)
    plt.show()
    
    print("total degree count: ")
    unique, counts = np.unique(total_node_degree, return_counts=True)
    print(np.asarray((unique, counts)).T)
        #total 48240
    
    print("local degree count: ")
    unique, counts = np.unique(local_node_degree, return_counts=True)
    print(np.asarray((unique, counts)).T)
        #total 43200
        
    print("global degree count: ")
    unique, counts = np.unique(global_node_degree, return_counts=True)
    print(np.asarray((unique, counts)).T)
        #total 5040. 
        #48240 = 43200 + 5040
    #    
    #    total degree count: 
    #    [[  32  360]
    #     [  34 1080]]
    #    local degree count: 
    #    [[  30 1440]]
    #    global degree count: 
    #    [[   2  360]
    #     [   4 1080]]
    
    #    '''
    #    So each node has same local degree, 30.
    #    
    #    360 nodes have global degree of 2 (so only one outgoing pair)
    #    1080 rest nodes have global degree of 4 (so two outgoing pairs)
    #    '''
    #    
    
    pass


def find_min_paths(src, dst, verbose = False):
    '''
    Here, min path means Dragonfly paths.
    
    So, we have a source group and a dest group.
    
    First we select a global link between the groups. Then the full paths
    are generatd as src + node + src_gateway + dest_gateway + node + dst.
    
    So, this is a five-hop path.
    
    Sometimes, the actual shortest path can be four, or even three hops, 
    if the src_gateway is present on the same row or same column as the src_node.
    OR, the dst_gateway is present on the same row or same column as the dst_node.
    
    When either of the options is true, we have a four-hop path:
        a) src + src_gateway + dst_gateway + node + dst
        b) src + node + src_gateway + dst_gateway + dst
    
    When both options are true, we have a three hop path:
        a) src + src_gateway + dst_gateway + dst
    
    '''
    
    src_group = src // _a
    dst_group = dst // _a
    
    if verbose:
        print("src, dst : ", src, dst)
        lay_down_an_edison_group(src_group)
        lay_down_an_edison_group(dst_group)
        
    #first, check if the nodes are in the same group
    if src_group == dst_group:
        path = find_shortest_paths_in_group(src, dst)
        if verbose:
            print(path)
        return path
    
    else:    
        #find global links 
        global_links = global_links_between_groups[(src_group, dst_group)]
        if verbose:
            print("global links: ",global_links)
            print("total global links: ", len(global_links))
            
        #randomly select a global link
        random_idx = random.randint(0, len(global_links)-1)
        (src_gateway, dst_gateway) = global_links[random_idx]
        if verbose:
            print(src_gateway, dst_gateway)
        
        path_0 = list(find_shortest_paths_in_group(src, src_gateway))
        path_1 = list(find_shortest_paths_in_group(dst_gateway, dst))
        
        path_0.extend(path_1)
        
        if verbose:
            print("path:", path_0)
        return path_0
        
    pass


def find_vlb_paths_vanilla(src, dst, verbose = True):
    '''
    Select an imdt node. Then get shortest paths for (src, imdt) and (imdt, dst)
    Merge them togetehr to get path in (src, imdt, dst) format.
    '''
    print("src, dst:", src, dst)
    
    imdt = random.randint(0, _nTOR)
    while (imdt == src) or (imdt == dst):
        imdt = random.randint(0, _nTOR)
    print("imdt: ", imdt)
    
    path_1 = find_min_paths(src, imdt)    
    path_2 = find_min_paths(imdt, dst)  
    
    if verbose:
        lay_down_an_edison_group(src//_a)
        lay_down_an_edison_group(imdt//_a)
        lay_down_an_edison_group(dst//_a)

    print(path_1)
    print(path_2)
    path = path_1[:len(path_1)-1] + path_2
    print(path)

def find_vlb_paths_in_group(src, dst, mode = 4, *, verbose = False):
    '''
    Inside a group, a vlb path can be either three or four hops depending on 
    the intermediate node selected.
    
    mode 3 -> 3 hop path
    mode 4 -> 4 hop path
    '''
    
    if verbose:
        print("src, dst:", src, dst)
    
    src_group = src // _a
    dst_group = dst // _a
    
    if src_group != dst_group:
        print("Error. src and dst are of diffent groups.")
        sys.exit(-1)
        
    if verbose:
        lay_down_an_edison_group(src_group)
     
    if mode == 4:
        path = _find_four_hop_vlb_paths_in_group(src, dst)
    elif mode == 3:
        path = _find_three_hop_vlb_paths_in_group(src, dst)
    else:
        print("Unsupported routing mode. Exiting.")
        System.exit(-1)
    
    if verbose:
        print(path)
        
    return path

    pass

def _find_three_hop_vlb_paths_in_group(src, dst, *, verbose = False):
    #generate a 3-hop path
    #select a node on the same row or column as in the src node
    #or, select a node on the same row or column as in the dst node
    src_group = src // _a
    dst_group = dst // _a
    
    src_row = (src - src_group * _a) // dims[0]
    src_col = (src - src_group * _a) % dims[0]
    
    dst_row = (dst - dst_group * _a) // dims[0]
    dst_col = (dst - dst_group * _a) % dims[0]
    
    imdt_candidates = []
    
    src_row_nodes = [(src_group*_a) + src_row * dims[0] + col for col in range(dims[0]) if col != src_col]
    dst_row_nodes = []
    if src_row != dst_row:
        dst_row_nodes = [(dst_group*_a) + dst_row * dims[0] + col for col in range(dims[0]) if col != dst_col]
    
    if verbose:
        print("src_row_nodeS:", src_row_nodes)    
        print("dst_row_nodeS:", dst_row_nodes)    
            
    src_col_nodes = [((src_group*_a) + row * dims[0] + src_col) for row in range(dims[1]) if row != src_row]
    dst_col_nodes = []
    if src_col != dst_col:
        dst_col_nodes = [((dst_group*_a) + row * dims[0] + dst_col) for row in range(dims[1]) if row != dst_row]
    
    if verbose:
        print("src_col_nodeS:", src_col_nodes)    
        print("dst_col_nodeS:", dst_col_nodes)    
            
    imdt_candidates = src_row_nodes
    imdt_candidates.extend(dst_row_nodes)
    imdt_candidates.extend(src_col_nodes)
    imdt_candidates.extend(dst_col_nodes)
    
    imdt_candidates = list(set(imdt_candidates))    #to remove duplicates
    
    if verbose:
        print("imdt_candidates:", imdt_candidates)
    
    imdt_node = imdt_candidates[random.randint(0, len(imdt_candidates)-1)]
    
    if verbose:
        print("imdt_node:", imdt_node)
    
    path1 = find_shortest_paths_in_group(src, imdt_node)
    path2 = find_shortest_paths_in_group(imdt_node, dst)
    vlb_path = path1[:len(path1)-1] + path2
    
    if verbose:
        print(path1)
        print(path2)
        print(vlb_path)
        
    return vlb_path

def _find_four_hop_vlb_paths_in_group(src, dst):
    '''
    randomly select an imdt node within the group
    '''
    
    src_group = src // _a
    dst_group = dst // _a
    
    imdt_node = random.randint((src_group*_a), ((src_group+1)*_a - 1))
    while(src == imdt_node) or (dst == imdt_node):
        imdt_node = random.randint((src_group*_a), ((src_group+1)*_a - 1))
    
    path1 = find_shortest_paths_in_group(src, imdt_node)
    path2 = find_shortest_paths_in_group(imdt_node, dst)
    print(path1)
    print(path2)
    vlb_path = path1[:len(path1)-1] + path2
    print(vlb_path)
    
    return vlb_path
    
    

def find_shortest_paths_in_group(src, dst, verbose = False):
    '''
    If the src and dst are in the same row, or in same column, there is only one shortest path.
    
    Else, there are two, and one will be randomly picked.
    '''
    
    src_group = src // _a
    dst_group = dst // _a
    
    if src_group != dst_group:
        print("Error. src and dst are of diffent groups.")
        sys.exit(-1)
    
    if verbose:
        lay_down_an_edison_group(src_group)
    
    src_row = (src - src_group * _a) // dims[0]
    src_col = (src - src_group * _a) % dims[0]
    
    dst_row = (dst - dst_group * _a) // dims[0]
    dst_col = (dst - dst_group * _a) % dims[0]
    
    #print(src, src_row, src_col)
    #print(dst, dst_row, dst_col)
    
    #are they in the same row
    #are they in the same column
    
    if src_row == dst_row or src_col == dst_col:
        path = (src, dst)
        if verbose:
            print("path:",path)

    #not in the same row or column
    else:
        #get the node at (dst_row, src_col)
        imdt1 = (src_group * _a) + dst_row * dims[0] + src_col
        #get the node at (src_row, dst_col)        
        imdt2 = (src_group * _a) + src_row * dims[0] + dst_col
    
        paths = [(src, imdt1, dst), (src, imdt2, dst)]
        if verbose:
            print("paths:", paths)
        
        #select one randomly
        idx = random.randint(0,len(paths)-1)
        path = paths[idx]
    
    #print(path)
    return path
    
    pass

def vizualize_global_connections_for_each_group(src_group):
    '''
    For the src_group, print out the global connections to each other group in the network.
    '''
    
    dst_groups = [x for x in range(_g) if x != src_group]
    
    lay_down_an_edison_group(src_group)
    print()
    
    for dst_group in dst_groups:
        #print()
        global_links = global_links_between_groups[(src_group, dst_group)]
        print("global links to group {} :".format(dst_group), end = " ")
        for global_link in global_links:
            print(global_link[0], end = " , ")
        print()
        print("total global links: ", len(global_links))
        print()
        
    
    pass

def intermediate_group_options(src, dst):
    '''
    Given a src and dst, show me options for intermediate groups of different lengths.
    For each group, show the number of candidate gateway nodes.
    
    update: seems like links are evenly balanced (except the last four columns, 
    but they are symmetric too).
    '''
    src_group = src//_a
    lay_down_an_edison_group(src)
    
    one_hope_neighbor_count = dims[0]-1 + dims[1]-1
    
    #zero hop, only the ones connected to the src node
    #skip the first 15+5 links
    #print("0 hop from src ", src, end = " -> ")
    
    zero_hop_count = {}
    one_hop_count = {}
    two_hop_count = {}
    
    for idx in range(one_hope_neighbor_count, len(graph[src])):
        tupl = graph[src][idx]
        #print(tupl, end= ",")
        imdt_group = tupl[0]//_a
        #print(imdt_group, end = ",")
        if imdt_group not in zero_hop_count:
            zero_hop_count[imdt_group] = 1
        else:
            zero_hop_count[imdt_group] += 1
            
    print("0 hop distribution (group, count): ")
    for k,v in zero_hop_count.items():
        print(k,v)
        
    print()
    
    #print("1 hop from src ", src, end = " -> ")
    #all nodes on the same row as src
    src_row = (src - src_group * _a) // dims[0]
    src_col = (src - src_group * _a) % dims[0]
    #print("nodes on the src row:")
    row_nodes = [(src_group * _a + src_row * dims[0] + ii) for ii in range(dims[0]) if (src_group * _a + src_row * dims[0] + ii) != src]
    #print(row_nodes)
    for node in row_nodes:
        #print("connected with ", node, end = " -> ")
        for idx in range(one_hope_neighbor_count, len(graph[node])):
            tupl = graph[node][idx]
            #print(tupl, end= ",")
            imdt_group = tupl[0]//_a
            #print(imdt_group, end = ",")
            if imdt_group not in one_hop_count:
                one_hop_count[imdt_group] = 1
            else:
                one_hop_count[imdt_group] += 1   
        
    #print()
    col_nodes = [(src_group * _a + ii * dims[0] + src_col) for ii in range(dims[1]) if (src_group * _a + ii * dims[0] + src_col) != src]
    #print(col_nodes)
    for node in col_nodes:
        #print("connected with ", node, end = " -> ")
        for idx in range(one_hope_neighbor_count, len(graph[node])):
            tupl = graph[node][idx]
            #print(tupl, end= ",")
            imdt_group = tupl[0]//_a
            #print(imdt_group, end = ",")
            if imdt_group not in one_hop_count:
                one_hop_count[imdt_group] = 1
            else:
                one_hop_count[imdt_group] += 1
    
    print("1 hop distribution (group, count): ")
    for k,v in one_hop_count.items():
        print(k,v)
    
        
    pass


def ugal_mt_src_group_options(src,dst,mode = 2):
    '''
    Just to lay down the logic on how the non-min path generation can work
    in the src_group for ugal_mt.
    
    mode 0: 0 hop
    mode 1: 1 hop
    mode 2: 2 hop
    '''
    
    if mode == 0:
        imdt_gateways = [tup[0] for tup in graph[src][20:]]
        print(imdt_gateways)
        
        #randomly select one
        selected_imdt_gw = imdt_gateways[random.randint(0, len(imdt_gateways)-1)]
        print(selected_imdt_gw)
        
        #randomly select a node in the imdt_group
        imdt_node = (selected_imdt_gw//_a)*_a + random.randint(0, _a-1)
        print(imdt_node)
        
        #generate path
        path = [src, selected_imdt_gw]
        path1 = find_shortest_paths_in_group(selected_imdt_gw, imdt_node)
        path2 = find_min_paths(imdt_node, dst)    
        print(path)
        print(path1)
        print(path2)
        path.extend(path1[1:])
        path.extend(path2[1:])
        print(path)
        
        print("src,imdt,dst:", src, imdt_node, dst)
        lay_down_an_edison_group(src//_a)
        lay_down_an_edison_group(imdt_node//_a)
        lay_down_an_edison_group(dst//_a)
        
    if mode == 1:
        print(src, dst)
        src_group = src//_a
    
        src_row = (src - src_group * _a) // dims[0]
        src_col = (src - src_group * _a) % dims[0]
        
        row_nodes = [(src_group * _a + src_row * dims[0] + ii) for ii in range(dims[0]) if (src_group * _a + src_row * dims[0] + ii) != src]
        col_nodes = [(src_group * _a + ii * dims[0] + src_col) for ii in range(dims[1]) if (src_group * _a + ii * dims[0] + src_col) != src]
        
        lay_down_an_edison_group(src_group)
        
        print("row nodes: ", row_nodes)
        print("col nodes: ", col_nodes)
        
        
        #generating the full neighbor list seems like inefficient. 
        #so randomly generate a number less than 20 and generate the corresponding neighbor only.
        #But it has a problem. no of global neighbors can vary between 1 and 2. 
        #So treatling all equally messes with the probability.
        
        rdm_idx = random.randint(0,37) # 37 = 12*2 + 4 + 10 - 1, because it starts from 0
        print("rdm_idx: ",rdm_idx)
        
        if rdm_idx < 24:
            col = rdm_idx // 2
            row = src_row
            port = rdm_idx % 2
        elif rdm_idx >= 24 and rdm_idx < 28:
            col = rdm_idx - 23
            row = src_row
            port = 0
        else:
            col = src_col
            row = (rdm_idx - 28) // 2
            if row >= src_row:
                row += 1
            port = (rdm_idx - 28) % 2
        
        print("row, col, port: ", row, col, port)        
                
        selected_neighbor = src_group * _a + row * dims[0] + col
        print("selected_neighbor: ", selected_neighbor)
        
        print("links in selected neighbor: ")
        list_all_outgoing_links_from_a_node(selected_neighbor)
        
        selected_imdt_gw = graph[selected_neighbor][20+port][0]
        print(selected_imdt_gw)
        
        #randomly select a node in the imdt_group
        imdt_node = (selected_imdt_gw//_a)*_a + random.randint(0, _a-1)
        print(imdt_node)
        
        #generate path
        path = [src, selected_neighbor, selected_imdt_gw]
        path1 = find_shortest_paths_in_group(selected_imdt_gw, imdt_node)
        path2 = find_min_paths(imdt_node, dst)    
        print(path)
        print(path1)
        print(path2)
        path.extend(path1[1:])
        path.extend(path2[1:])
        print(path)
        
        print("src,imdt,dst:", src, imdt_node, dst)
        lay_down_an_edison_group(src//_a)
        lay_down_an_edison_group(imdt_node//_a)
        lay_down_an_edison_group(dst//_a)
        
    if mode == 2:
        #just randomly select any imdt_node, gateway doesn't matter
        
        imdt_node = random.randint(0, _nTOR)
        print(imdt_node)
        
        #generate path
        path = find_min_paths(src, imdt_node)
        path2 = find_min_paths(imdt_node, dst)    
        print(path)
        print(path2)
        path.extend(path2[1:])
        print(path)
        
        print("src,imdt,dst:", src, imdt_node, dst)
        lay_down_an_edison_group(src//_a)
        lay_down_an_edison_group(imdt_node//_a)
        lay_down_an_edison_group(dst//_a)
        
        
       
        
        
#        #randomly select a node in the imdt_group
#        imdt_node = (selected_imdt_gw//_a)*_a + random.randint(0, _a)
#        print(imdt_node)
#            
#        #generate path
#        path = [src, selected_imdt_gw]
#        path1 = find_shortest_paths_in_group(selected_imdt_gw, imdt_node)
#        path2 = find_min_paths(imdt_node, dst)    
#        print(path)
#        print(path1)
#        print(path2)
#        path.extend(path1[1:])
#        path.extend(path2[1:])
#        print(path)
#        
#        print("src,imdt,dst:", src, imdt_node, dst)
#        lay_down_an_edison_group(src//_a)
#        lay_down_an_edison_group(imdt_node//_a)
#        lay_down_an_edison_group(dst//_a)
#        
#            
#        lay_down_an_edison_group(src//_a)
#        
    pass
    

'''
#TODO:
    1. A function that decides which source gateway to take depending on mode
    2. A function to generate complete vlb path    
'''

if __name__ == "__main__":
    print("Hello World!")
    
    _n = 2 #dimension
    _a = 96 #group_size
    _g = 15 #no of edison groups
    
    _nTOR = _a * _g #total no of routers
    
    dims  = [16, 6]
    
    graph = [[] for x in range(_nTOR)]
    
    global_links_between_groups = {}
        #key = tuple(src_group, dst_group)
        #value = list of (src,dst) pairs, indicating links goig through the groups
    
    connect_all_groups(graph)    
    
    connect_global_connections(graph)
    
#    for src, dsts in enumerate(graph):
#        print(src, dsts)
    
    #create_graph()
    G = generate_nx_graph(graph)
    
    #src = 21
    #dst = 190
    #intermediate_group_options(src,dst)
    #ugal_mt_src_group_options(src,dst, mode = 2)    
    
    #lay_down_an_edison_group(14)
    
    #validate_path_between_nodes(2,92,G)
    #validate_path_between_nodes(37,178,G, graph)
    
    #visualize_global_links(G)
#    src = 49
#    dst = 1161
#    find_shortest_paths_in_group(src, dst, verbose=True)
##    
    src = 983   
    dst = 1079
    find_min_paths(src, dst, verbose=True)
    list_all_outgoing_links_from_a_node(src)
    
    src = 355   
    dst = 1079
    find_min_paths(src, dst, verbose=True)
    
    
#    src = 658
#    dst = 501
#    find_min_paths(src, dst, verbose=True)
#    list_all_outgoing_links_from_a_node(src)
##    src = 1234
#    dst = 918
#    find_min_paths(src, dst, verbose=True)
#    list_all_outgoing_links_from_a_node(src)
##   
#    
#    src = 159
#    dst = 1017
#    find_min_paths(src, dst, verbose=True)
#    src = 1017
#    dst = 787
#    find_min_paths(src, dst, verbose=True)
#    
#    src = 159
#    dst = 1112
#    find_min_paths(src, dst, verbose=True)
#    src = 1112
#    dst = 787
#    find_min_paths(src, dst, verbose=True)
    
#    vizualize_global_connections_for_each_group(0)
    
#    src = 133
#    list_all_outgoing_links_from_a_node(src)
#    
#    src = 1439
#    list_all_outgoing_links_from_a_node(src)
#    

#    src = 3
#    dst = 191
#    find_vlb_paths_vanilla(src, dst)
    
#    src = 3
#    dst = 91
#    find_vlb_paths_in_group(src, dst, mode = 3, verbose = True)
#                            
    print("Done.")
    