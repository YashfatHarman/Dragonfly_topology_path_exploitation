'''
Uses djkstra paths only. 
If you want DF paths, use different functions.
'''

from djkstra import all_pair_all_shortest_paths_djkstra
import sys

def create_MIN_paths_list(G, traffic, all_pair_min_paths = None, *, verbose = False):
    '''
    A function that creates a MIN path list for only the s-d pairs present in the traffic pattern.
    
    This is needed to make MIN-path method compatible to the corresponding VLB-path one.
    
    Previously we were using all_pair_all_shortest_paths_djkstra() for the passing the paths,
    but that creates a 3D list. On the other hand, VLB-path functions creates a dict with (s,d)
    pair tuple as the key. This causes access incoherence in the functions which intend to 
    work with the path list.
     
    
    Returns: a dict with keys (s,d) and value: list of path tuples. 
    '''
    
    if all_pair_min_paths == None:
        all_pair_min_paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w", print_paths = False)
    
    all_MINpaths = {}
    
    for src,dst in traffic:
        minpaths = [tuple(path) for path in all_pair_min_paths[src][dst]]
        all_MINpaths[(src,dst)] = minpaths
        
    if verbose:
        print("\nMin paths for each pair:")
        for sdpair, paths in all_MINpaths.items():
            print(sdpair, " -> ", paths)
        
    return all_MINpaths
    
    pass


def create_VLB_paths_list(G, a, trafficPattern, all_pair_min_paths = None, *, mode = 0, verbose = True):
    '''
    G: networkx Graph object
    
    a = DF parameter a, reuqired to find the group id of a node
        
    Traffic pattern: A list of (S,D) tuple.
                    S and D are routers, *NOT* PEs
                    
    mode: How the VLB paths will be selected.
        This decides the max path len in first and second phase of VLB routes.
        In Dragonfly, max path len for min routing can be 3.
        So each phase can have 3 hops, or less.
        
        Mode 0: <= 3 + <= 3  => unrestricted VLB routing, default case
        Mode 1: < 3  + <= 3  => First phase restricted
        Mode 2: <= 3  + < 3  => Second phase restricted
        Mode 3: < 3  + < 3  =>  Both phase restricted
                    
    returns: A dict of (s,d) pair keys and pathlist in values.
            pathlist is list of tuples. Each tuple contains the node ids in the path.
    '''
    
    '''
    #for each S-D pair, we need all the VLB paths.
    
    #for an SD, each other node can be a potential I node.
        #So for each I node, we need all S-I-D paths.
        #If there are multiple paths in the S-I and I-D portion, then it is even more complex.
        #In that case, if there are m1 paths in the S-I part and m2 paths in the I-D part, 
            #then there are a total of m1*m2 number of total paths for this S-I-D quad only.
    
    #how big is the total number of paths?
    #In a DF, total number of PE is a*g*p. Say, N.
    #Then in a randperm, there are N number of SD pairs.
    #Each of the a*g-2 routers  can act as an I.
    #So total SID combo: N*(a*g-2)
    #For single paths only, we are talking about N*(a*g-2) paths.
        #For multipaths, it will be bigger.
    
    #For a = 8, h = 4, p =4. If g = 33, then N = 33 * 8 * 4 = 264 * 4 = 1056
    #So total SID combo: 1056 * (8*33-2) = 278 784 = 0.28 M
    
    #if g = 15, N = 15 * 8 * 4 = 120 * 4 = 480
    # so total SID combo: 480 * (8*15-2) = 57600 = 0.057 M
    
    #For a = 16, h = 8, p = 8. If g = 129, then N = 129 * 16 * 8 = 2064 * 8 = 16512
    #so total SID combo: 16512 * (16*129-2) = 34 080 768 = 34M
    
    #if g = 40, then N = 40 * 16 * 8 = 640 * 8 = 5120
    #so total SID combo: 5120 * (16*40) = 3 276 800 = 3M
    '''
    
    #ok, complexity aside. here are the steps.
    
    #First, call djkstra to get the shortest paths among all the pairs.
    
    #Then get the traffic pattern. 
    #For each SD router combo, get every other router as an intermediate router I.
        #Get all the paths for (S,I) and (I,D) from the djkstra table.
        #combine the paths. So essentially m1 * m2 number of paths for each SID combo.
    #So for each SD, get a dict of (S,D) vs list of all paths from all (SID) triplet. Basically, all VLB paths.
    
    #pass this (S,D) vs [All VLB paths] to the Jain's method.
    
    if all_pair_min_paths == None:
        all_djkstra_paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
    else:
        all_djkstra_paths = all_pair_min_paths
        
    N = len(G)
    
    all_VLBpaths = {}
    
    if mode == 0:
        max_SI_pathlen = 3
        max_ID_pathlen = 3
    elif mode == 1:
        max_SI_pathlen = 2
        max_ID_pathlen = 3
    elif mode == 2:
        max_SI_pathlen = 3
        max_ID_pathlen = 2
    elif mode == 3:
        max_SI_pathlen = 2
        max_ID_pathlen = 2
    else:
        print("invalid mode: ", mode)
        sys.exit(1)
    
    #for each SD pair
    for (src,dst) in trafficPattern:
        if src == dst:
            continue
        
        SDpair_all_VLBpaths = set()
        
        srcGroup = src//a
        dstGroup = dst//a
        #print("groups:", srcGroup, dstGroup)
        
        #if src and dst are in the same group
        if srcGroup == dstGroup:
            #select imdt from only within that group
            imdt_lst = [x for x in range(srcGroup*a, (srcGroup+1)*a )  if x != src and x != dst]
            
        else:
            #we want to skip the routers that are in the same group as the src and the dst
            imdt_lst = [x for x in range(N) if x//a != srcGroup and x//a != dstGroup]
        #print("imdt_lst:", imdt_lst)
            
        #for each possible imdt router
        for imdt in imdt_lst:
#            if src == imdt or dst == imdt:
#                continue
                #not needed anymore as omitting srcGroup and dstGroup is taking care of this case as well.
                
            #construct all VLB path
            SIpaths = [path for path in all_djkstra_paths[src][imdt] if len(path) <= (max_SI_pathlen+1)]
            IDpaths = [path for path in all_djkstra_paths[imdt][dst] if len(path) <= (max_ID_pathlen+1)]
                    #paths contain src and dst nodes, so hop number is one less than the number of nodes in the path
            
            #print(src, imdt, " : ", SIpaths)
            #print(imdt, dst, " : ", IDpaths)
            
            #VLBpaths = [ tuple( list(path1) + list(path2)[1:]) for path1 in SIpaths for path2 in IDpaths ]
            #print(VLBpaths)
            
            for path1 in SIpaths:
                for path2 in IDpaths:
                    SDpair_all_VLBpaths.add( tuple( list(path1) + list(path2)[1:]) )
            
            
            
            #        print("\n\n")
            #        print(src,dst,"all vlb paths:")
            #        print(SDpair_all_VLBpaths)
            #        
        
        all_VLBpaths[(src,dst)] = list(SDpair_all_VLBpaths)
    
    if verbose:
        print("\nVLB paths for each pair:")
        for sdpair, paths in all_VLBpaths.items():
            print(sdpair, " -> ", paths)
    
    return all_VLBpaths
    
    pass


def merge_MIN_and_VLB_paths(G, a, trafficPattern, all_pair_min_paths = None, *, mode = 0, verbose = True):
    '''
    As the name suggests, this function takes a topology and traffic pattern, then
    generates all the min and VLB paths, and merges them together.
    Can be used to apporximate something similar to UGAL routing.
    
    As usual:
        G: networkx Graph object
    
        a = DF parameter a, reuqired to find the group id of a node
            
        Traffic pattern: A list of (S,D) tuple.
                        S and D are routers, *NOT* PEs
                        
        all_pair_min_paths: the caller function may call djkstra itself and send the 
                        paths as a parameter which will be used to find min and 
                        vlb paths. If None, then the djkstra-paths will be generated
                        inside the min and vlb functions.
                        
                        If sent, it's a 3D list of format [src][dst][lst of all path tuples]
                        
        mode: How the VLB paths will be selected.
            This decides the max path len in frist and second phase of VLB routes.
            In Dragonfly, max path len for min routing can be 3.
            So each phase can have 3 hops, or less.
            
            Mode 0: <= 3 + <= 3  => unrestricted VLB routing, default case
            Mode 1: < 3  + <= 3  => First phase restricted
            Mode 2: <= 3  + < 3  => Second phase restricted
            Mode 3: < 3  + < 3  =>  Both phase restricted
    
    
    returns: A dict of (s,d) pair keys and pathlist in values.
            pathlist is list of tuples. Each tuple contains the node ids in the path.
    
    '''
    
    #will save time for one run
    if all_pair_min_paths == None:
        all_djkstra_paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
    else:
        all_djkstra_paths = all_pair_min_paths
    
    all_min_paths = create_MIN_paths_list(G, trafficPattern, all_pair_min_paths = all_djkstra_paths, verbose = False)
    
    all_vlb_paths = create_VLB_paths_list(G, a, trafficPattern, all_pair_min_paths = all_djkstra_paths, mode = mode, verbose = False)
    
    if verbose:
        print("\n generated the paths.")
        
        for (src,dst) in trafficPattern:
            print("({}, {})".format(src,dst))
            print("min: ", all_min_paths[(src,dst)])
            print("vlb: ", all_vlb_paths[(src,dst)])
            
    #paths returned, now merge
    all_combined_paths = {}
    
    for (src,dst) in trafficPattern:
        all_combined_paths[(src,dst)] = [ *all_min_paths[(src,dst)], *all_vlb_paths[(src,dst)] ]
            #shallow copy. But in this case it's fine.
            
    if verbose:
        print("\n merged paths.")
        
        for (src,dst) in trafficPattern:
            print("({}, {})".format(src,dst))
            print(all_combined_paths[(src,dst)])
            
    return all_combined_paths
            
    pass








































