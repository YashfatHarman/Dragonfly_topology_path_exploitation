import networkx as nx
import time
import djkstra

def FloydWarshall(weighted_adj_list):
    '''
    Weighted adjacency list: a list of list of tuples.
                Each row represents a node.
                Each row contains the list of tuple, one tuple for each neighbor.
                Each tuple has two elements (a,b):  a -> neighbor node, 
                                                    b -> weight of the link to a
                
    Weighted adjacency list will look kinda like this for a graph with nodes 0 to 3:
        0 [(1, 1), (3, 1)]
        1 [(0, 1), (2, 1)]
        2 [(1, 1), (3, 1)]
        3 [(0, 1), (2, 1)]
    '''
    
    '''
    We need a N*N matrix.
    Initialize the (i,i) cells as 0.
    Initilize all the (i,j) cells for each link to its weight.
    Initialize everything else to INF.
    
    '''
    N = len(weighted_adj_list)
    INF = 9999
    
    FW_table = [ [INF for x in range(N)] for x in range(N)]
    Next_node_table = [ [ [] for x in range(N)] for x in range(N)]
    
    for i in range(N):
        FW_table[i][i] = 0
        
    for src in range(N):
        for (dst, weight) in weighted_adj_list[src]:
            FW_table[src][dst] = weight 
            Next_node_table[src][dst] = [dst]
    
    #    print("initial FW table:")
    #    for row in FW_table:
    #        print(row)
    #    
    #    print("inital Parent table:")
    #    for row in Next_node_table:
    #        print(row)
    #    
    for imdt in range(N):
        for src in range(N):
            if imdt == src:
                continue
            for dst in range(N):
                if dst == src or dst == imdt:
                    continue
                if FW_table[src][imdt] + FW_table[imdt][dst] < FW_table[src][dst]:
                    FW_table[src][dst] = FW_table[src][imdt] + FW_table[imdt][dst]
                    Next_node_table[src][dst] = Next_node_table[src][imdt][:]
                
                elif ( FW_table[src][imdt] + FW_table[imdt][dst] == FW_table[src][dst]) and (FW_table[src][dst] != INF):
    #                    print(src,imdt,dst, " : ", Next_node_table[src][dst], Next_node_table[src][imdt])
    #                    print("before")
    #                    for node,row in enumerate(Next_node_table):
    #                        print(node,row)
    #    
                    Next_node_table[src][dst].extend(Next_node_table[src][imdt])
    #                    print(Next_node_table[src][dst])
    #
    #                    print("after")
    #                    for node,row in enumerate(Next_node_table):
    #                        print(node,row)
    
                pass
    
    #    print("final FW table:")
    #    for row in FW_table:
    #        print(row)
    #    
    #    print("final Parent table:")
    #    for node,row in enumerate(Next_node_table):
    #        print(node,row)
    
    return FW_table, Next_node_table
    
    pass


def get_path(src, dst, Next_node_table):
    
    if src == dst:
        return [[src]]
    
    all_paths = []
    
    path = [src]
    
    get_path_internal(src,dst, path, all_paths, Next_node_table)
    
    #    print("\npaths:")
    #    for path in all_paths:
    #        print(path)
    #
    
    return all_paths
    
    pass
    
def get_path_internal(current, dst, path, all_paths, Next_node_table ):
    '''
    Internal helper function that gets called by get_path() to facilitate recursion.
    '''
    if Next_node_table[current][dst][0] == dst:
        #path found
        path.append(dst)
        all_paths.append(path)
        return
    
    if len(Next_node_table[current][dst]) == 1:
        next = Next_node_table[current][dst][0]
        path.append(next)
        get_path_internal(next, dst, path, all_paths, Next_node_table)
    else:
        for next in Next_node_table[current][dst]:
            path_copy = path[::]
            path_copy.append(next)
            get_path_internal(next, dst, path_copy, all_paths, Next_node_table)
        
    pass

def all_pair_all_shortest_paths_floyd_warshall(Graph, * , edge_weight = "w", verbose = False):
    '''
    Returns:
        paths: list of list of list of tuples. 
        
        For each src and dst, paths[src][dst] contains all a list of tuples. 
        Each tuple is a shortest path between src and dst.
    '''
    
    N = len(Graph)
    #print("total nodes: ", N)
    
    #first create a suitable adjacency matrix representation for the graph
    edge_list = []  #just to print the graph. Test purpose only.
    weighted_adj_list = [ [] for x in range(N) ]
    
    for edge in Graph.edges(data = True):
        #print(edge)
        #print(edge[0], edge[1], edge[2]["wight"], edge[2]["w"])
        src = edge[0]
        dst = edge[1]
        weight = edge[2][edge_weight]
        weighted_adj_list[src].append((dst,weight))
        weighted_adj_list[dst].append((src,weight))
        edge_list.append((src,dst,weight))
    
#    if verbose:
#        print("edge_list:")
#        for edge in edge_list:
#            print(edge)
#            
#        print("weighted_adj_list :")
#        for node, neighbors in enumerate(weighted_adj_list):
#            print(node, neighbors)
#    
    start_time = time.time()            
    FW_table, Next_node_table = FloydWarshall(weighted_adj_list)
    end_time = time.time()
    time1 = end_time - start_time
    print("FW runtime:", time1)

    #now generate all the paths
    paths_fw = [ [ [] for x in range(N) ] for x in range(N) ]
    
    start_time = time.time()
    for src in range(N):
        for dst in range(N):
            paths_fw[src][dst] = [tuple(x) for x in get_path(src,dst,Next_node_table)]
    end_time = time.time()
    
    time2 = end_time - start_time
    
    print("path generation time:", time2)
    print("FW total time: ", time1+time2)    
    
    if verbose:
        print("paths:")
        for src in range(N):
            for dst in range(N):
                print(src,dst,"->",paths_fw[src][dst])
        
    #print("\n\ntesting path creation:")
    #get_path(5,0, Next_node_table)
    
    return paths_fw
    
    pass

def compare_paths_by_djkstra_and_floyd_warshall():
    '''
    As the name suggests. Just a test function.
    '''
    
    G = intro_code_to_test_something.create_dragonfly(a=8, g = 17, arrangement = "absolute_improved")
    intro_code_to_test_something.draw_graph(G)
    
    paths_fw = all_pair_all_shortest_paths_floyd_warshall(G, verbose = False)
    
    paths_dj = djkstra.all_pair_all_shortest_paths_djkstra(G, print_paths = False)
    
    #paths_dj[5][5].append((1,2))
    
    
    path_validness = djkstra.check_path_validness(paths_fw, paths_dj)
    
    print("path validity: ", path_validness)
    
    #TODO: 
    # issue: FW seems to be an order of magnitude slow that djkstra. Not sure why.
    # for the time being, djkstra seems to be the way forward.           
    
    
    pass


if __name__ == "__main__":
    print("Hello World")
    
    import intro_code_to_test_something
    compare_paths_by_djkstra_and_floyd_warshall()

    print("Bye World. Go die.")