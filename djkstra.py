import networkx as nx
import heapq
import time
import graphCreationAndDraw as GD


#implement djkstra
def djkstra(src, N, graph):
    '''
    Finds all weighted shortest paths from src.
    Returns a list of len N. each index in the list contains the list of all shortest paths src to that index.
    
    Parameters:
        src: the node from where the paths are started
        N: total nodes in the network
        graph:  Adjacency list along with path weight
                For each src node, there will be a list of (dst, link_weight) tuples
    '''
    #initially all node has a distance of INF
    #set source distance to 0. Push source to heap.
        #while heap is not empty:
            #pop the top element from heap
            #check all its neighbors. 
                #If not already visited, update their weight.
                #push them in the heap. Mark them as visited.
    MAX = 10000

    weights = [MAX for x in range(N)]
    
    parents = [ [] for x in range(N)]
    
    paths = [[] for x in range(N)]
    
    visited = set()
    heap = []
    
    weights[src] = 0
    parents[src].append(-1) #-1 will work like a path terminator
    
    heapq.heappush(heap, (weights[src],src))
    
    while (len(heap) > 0):
        top_weight, top = heapq.heappop(heap)
        visited.add(top)
        for neighbor,weight in graph[top]:
            if neighbor not in visited:    #not visited
                if weights[top] + weight < weights[neighbor]:
                    weights[neighbor] = weights[top] + weight
                    parents[neighbor] = [top]
                    heapq.heappush(heap, (weights[neighbor], neighbor) )
                elif weights[top] + weight == weights[neighbor]:
                    weights[neighbor] = weights[top] + weight
                    parents[neighbor].append(top)
                    heapq.heappush(heap, (weights[neighbor], neighbor) )
                
    #generate the paths
    for node in range(N):
        path = []
        gen_path(path, node, node, paths, parents)
    
                
    #    print("final weights for src", src)
    #    for idx,weight in enumerate(weights):
    #        print(idx, weight)
    #        
    #    print("final parents for src",src)
    #    for idx, parent in enumerate(parents):
    #        print(idx, parent)
    #    

#    print("all paths:")
#    for idx in range(N):
#        print(idx, paths[idx])
#        
    return paths

    pass

def all_pair_all_shortest_paths_djkstra(Graph, * , edge_weight = "w", print_paths = False):
    '''
    Input: Graph, a networkx graph object.
    
    Returns: A list of paths. For each src and dst, paths[src][dst] contains
        a list of tuples. Each tuple is a shortest path between src and dst.
    
    It calls Djkstra on each src. So the process is repeated N times.
    
    '''
    N = len(Graph)
    #print("total nodes: ", N)
    
    #first create a suitable adjacency matrix representation for the graph
    edge_list = []  #just to print the graph. Test purpose only.
    weighted_adj_list = [ [] for x in range(N) ]
    
    for edge in Graph.edges(data = True):
        #print(edge)
        #print(edge[0], edge[1], edge[2]["wight"], edge[2]["w"])
        src = edge[0]
        dst = edge[1]
        weight = edge[2][edge_weight]
        weighted_adj_list[src].append((dst,weight))
        weighted_adj_list[dst].append((src,weight))
        edge_list.append((src,dst,weight))
    
#    print("The wieghted_adjacency_list:")
#    for src, tup in enumerate(weighted_adj_list):
#        print(src, tup)
#    print("end of adjacency_list\n")
#    
    start_time = time.time()
    
    paths = [[ [] for x in range(N) ] for x in range(N) ]
    
    for src in range(N):
        paths_djkst = djkstra(src, N, weighted_adj_list)
        
        for dst in range(N):
            paths[src][dst] = [tuple(x) for x in paths_djkst[dst]]
                
    end_time = time.time()
    #print("djkstra path generation and copying time:", end_time - start_time)    
        
    if print_paths:
        print("\npaths:")
        for src in range(N):
            print("\nsrc:",src)
            for dst in range(N):
                print(src,dst, paths[src][dst])
        
    return paths

    pass

def all_pair_all_shortest_paths_networkx(Graph, edge_weight = "w"):
    '''
    Input: Graph, a networkx graph object.
    
    Returns: A list of paths. For each src and dst, paths[src][dst] contains
        a list of tuples. Each tuple is a shortest path between src and dst.
    
    It calls networkx.all_shortest_paths() on each src-dst pair. So the process is repeated N^2 times.
    
    networkx.all_shortest_paths() is extremely slow. This function is here for test only.
    
    Use Djkstra instead for regular task.
    '''
    
    N = len(Graph)
    #print("total nodes: ", N)
    
    paths = [[ [] for x in range(N) ] for x in range(N) ]
    
    for src in range(N):
        for dst in range(N):
            paths[src][dst] = [tuple(x) for x in nx.all_shortest_paths(Graph, source = src, target = dst, weight = edge_weight)]


#    print("\npaths1:")
#    for src in range(N):
#        print("\nsrc:",src)
#        for dst in range(N):
#            print(src,dst, paths[src][dst])
#    
    return paths

    pass

def gen_path(path, node, dst, all_paths, parents):
    '''
    Path: running path, accumulated through each recursion
    node: current node
    dst: the ultimate destination node for which this path is generated
    all_paths: data structure that contains paths to all the dst nodes
    parents: data structure, populated by djkstra. Basically keep the predecessor node 
            determined through djkstra algorithm.
    '''
    #print(path, node, dst)
    path.append(node)
    
#    for parent in parents[node]:
#        if parent == -1:
#            all_paths[dst].append(path[::-1])
#        else:
#            path_copy = path[::]
#            #print("path_copy:", path_copy)
#            gen_path(path_copy, parent, dst, all_paths, parents)

    #if there is only one parent, no branching is necessary. Pass the path by reference.
    if len(parents[node]) == 1:
        parent = parents[node][0]
        if parent == -1:
            all_paths[dst].append(path[::-1])
        else:
            #path_copy = path[::]
            #print("path_copy:", path_copy)
            gen_path(path, parent, dst, all_paths, parents)
            
    #multiple path, branching needed. Each branch need to have a copy of the path. So send a copy.
    else:
        for parent in parents[node]:
            if parent == -1:
                all_paths[dst].append(path[::-1])
            else:
                path_copy = path[::]
                #print("path_copy:", path_copy)
                gen_path(path_copy, parent, dst, all_paths, parents)
            
    pass


def check_path_validness(paths1, paths2):
    '''
    Paths1 and paths2 are list of list of tuples. Each tuple is a path. 
    '''
    #first check the len of the pathsets
    #then check the length of the corresponding indexes
    #finally, check the individual tuples in the corresponding rows.
    
    #    print("inside check_path_validness")
    #    print("len(paths1):", len(paths1))
    #    print("len(paths2):", len(paths2))
    #    
    if len(paths1) != len(paths2):
        return False
    
    for src in range(len(paths1)):
        #print("src:", src)
        if len(paths1[src]) != len(paths2[src]):
            return False
#        if src == 11:
#            print("len(paths1[11]):", len(paths1[src]))
#            print("len(paths2[11]):", len(paths2[src]))
#    
        for dst in range(len(paths1[src])):
#            if src == 11 and dst == 6:
#                print("paths1:",paths1[src][dst])
#                print("paths2:",paths2[src][dst])
            if len(paths1[src][dst]) != len(paths2[src][dst]):
                return False
            if set(paths1[src][dst]) != set(paths2[src][dst]):
                return False
    return True

    pass

def test_djkstra():
    '''
    As the name suggests. Just a test function.
    '''
    
    G = GD.create_topology(a=2, g = 2, arrangement = "absolute_improved")
    GD.draw_graph(G)
    
    #paths_fw = all_pair_all_shortest_paths_floyd_warshall(G, verbose = False)
    
    paths_dj = all_pair_all_shortest_paths_djkstra(G, print_paths = False)
    
    #paths_dj[5][5].append((1,2))
    
    
    #path_validness = djkstra.check_path_validness(paths_fw, paths_dj)
    
    #print("path validity: ", path_validness)
    
    #TODO: 
    # issue: FW seems to be an order of magnitude slow that djkstra. Not sure why.
    # for the time being, djkstra seems to be the way forward.           
    
    
    pass

def djkstra_all_pair_all_shortest_path_distribution_stat():
    '''
    generate the all_pair_all_shortest_path data structure.
    Then go through each pair and change path-len.
    Make a histogram.
    '''
    a = 8
    g = 5
    G = GD.create_topology(a=a, g = g, arrangement = "absolute_improved")
    GD.draw_graph_circular(G, a = a)
    
    #paths_fw = all_pair_all_shortest_paths_floyd_warshall(G, verbose = False)
    
    paths_dj = all_pair_all_shortest_paths_djkstra(G, print_paths = False)
    
    len_dict = {}
    for ii in range(7):
        len_dict[ii] = 0
    
    for src in range(len(G)):
        for dst in range(len(G)):
            pathlen = len(paths_dj[src][dst][0])-1
            print(src,dst, paths_dj[src][dst][0])
            len_dict[pathlen] += 1
            
    print("path distribution:")
    for k,v in sorted(len_dict.items()):
        print(k, " : ", v)
    
    
    pass


if __name__ == "__main__":
    print("hello world.")
    
    #test_djkstra()
    djkstra_all_pair_all_shortest_path_distribution_stat()
    
    print("Die!")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    