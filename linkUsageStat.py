#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Mar 28 17:39:08 2019

@author: rahman
"""

from test_jains_and_mcf import create_topology, draw_graph_circular

from Dragonfly_paths import generate_graph_adjacency_list, get_list_of_links_between_each_group_pair, generate_list_of_2hop_neighbors, generate_list_of_nodes_connected_to_group_pairs, inodes_for_4hop_paths_for_all_SD_pairs, inodes_for_3hop_paths_for_all_SD_pairs

from traffic import create_random_permutation_pattern, create_shift_traffic_pattern
from djkstra import all_pair_all_shortest_paths_djkstra
from mcf import inode_generator_5hop_src_and_dst, inode_generator_5hop_src_only, inode_generator_for_3hop_paths, inode_generator_for_4hop_paths

import sys
import operator 
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd
import datetime
import os

def calculateLinkUsage(graph_adj_list, SDpairs, mode, vlbPathList, twoHopNeighborList, *, a, g, p):
    '''
    SDpairs = An array of (src_PE, dst_PE)
    
    mode: string, "src_only" or "src_and_dst"
    
    vlbPathList: 
        Paths going to be used to calculate vlb-path loads.
        A 3D array where paths are stored as [src][dst][min paths between src and dst].
        Each path is a list of tuples.
        Note, that this is still listing min paths between an SD pair.
        Listing all VLB paths will be too memory-consuming.
        However, a separate pathlist is still necessary because in some cases, we may
        want to use separate min paths lists for min and vlb path load calculation.
        (For example, Df_min paths for min, and djkstra-min for vlb for ugal_restricted.)
    
    '''
    
    if mode == "src_only":
        inodeGenerator = inode_generator_5hop_src_only
    elif mode == "src_and_dst":
        inodeGenerator = inode_generator_5hop_src_and_dst
    else:
        print("Unsupported mode:", mode)
        sys.exit(-1)
    
    N = a * g
    
    link_vs_usage = {}
    
    inodegenerator_kwargs = {"N" : N, 
                             "a" : a, 
                             "twoHopNeighborList" : twoHopNeighborList, 
                             }
    
    
    #for each pair, get the list of VLB paths between them
    for src_PE, dst_PE in SDpairs:
        src_router = src_PE // p
        dst_router = dst_PE // p
        
        inodes = inodeGenerator(src_router, dst_router, **inodegenerator_kwargs)
        #print(src_router, dst_router, inodes)
        
        inode_count = len(inodes)
        for inode in inodes:
            src_imdt_paths = vlbPathList[src_router][inode]
            imdt_dst_paths = vlbPathList[inode][dst_router]
            #print(src_imdt_paths, imdt_dst_paths)
            
            #grab each link in the first half
            path_count = len(src_imdt_paths)
            for path in src_imdt_paths:
                #print(path)
                for idx in range(len(path)-1):
                    src,dst = path[idx], path[idx+1]
                    #print(src,dst)
                    #print("inode_count, path_count", inode_count, path_count)
                    if (src,dst) not in link_vs_usage:
                        link_vs_usage[(src,dst)] = 1/inode_count * 1/path_count
                    else:
                        link_vs_usage[(src,dst)] += 1/inode_count * 1/path_count
                    
            #grab each link in the second half
            path_count = len(imdt_dst_paths)
            for path in imdt_dst_paths:
                #print(path)
                for idx in range(len(path)-1):
                    src,dst = path[idx], path[idx+1]
                    #print(src,dst)
                    #print("inode_count, path_count", inode_count, path_count)
                    if (src,dst) not in link_vs_usage:
                        link_vs_usage[(src,dst)] = 1/inode_count * 1/path_count
                    else:
                        link_vs_usage[(src,dst)] += 1/inode_count * 1/path_count
  
    return link_vs_usage
    pass


def countGlobalLinkUsage(G, sd_pairs, mode, vlbPathList, *, a, g, p, h): 
    '''
    Make sure to set p = 1 while considering router-based traffic.
    
    We want to figure out how the global links are being used for a traffic pattern.
    
    The idea is, for each SD pair, if all the global links are not being used to VLB routing,
    then there may not be a proper load distribution.
    
    For each SD pair:
        - get all the inodes
        - calculate all paths
        - find the global link usage
        - important: get statistic of how many global links go unused, if any
        
    For the time being, only consider modes: 3hop_paths_only and 4hop_paths_only
    
    Additional modes to consider: 5hop_paths_only, all
    ''' 
    
    #default values, duh
    sd_pair_vs_4hop_inodes = None
    sd_pair_vs_3hop_inodes = None
    twoHopNeighborList = None
    
    if mode == "4hop_paths_only":
        _graph_adj_list = generate_graph_adjacency_list(G)
        _group_pair_vs_nodes = generate_list_of_nodes_connected_to_group_pairs(_graph_adj_list, a)
        
        sd_pair_vs_4hop_inodes = inodes_for_4hop_paths_for_all_SD_pairs(sd_pairs, G, _graph_adj_list, _group_pair_vs_nodes, edge_weight = "w", a = a, g = g, p = p)
        inode_generator = inode_generator_for_4hop_paths
        
    elif mode == "3hop_paths_only":
        _graph_adj_list = generate_graph_adjacency_list(G)
        #group_pair_vs_nodes = DP.generate_list_of_nodes_connected_to_group_pairs(graph_adj_list, a)
        _group_pair_vs_global_links = get_list_of_links_between_each_group_pair(G, edge_weight = "w", a = a, g = g )
        
        twoHopNeighborList = generate_list_of_2hop_neighbors(G, _group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
        sd_pair_vs_3hop_inodes = inodes_for_3hop_paths_for_all_SD_pairs(sd_pairs, G, _graph_adj_list, twoHopNeighborList, edge_weight = "w", a = a, g = g, p = p)
        inode_generator = inode_generator_for_3hop_paths
        
    elif mode == "5hop_src_only":
        _graph_adj_list = generate_graph_adjacency_list(G)
        _group_pair_vs_global_links = get_list_of_links_between_each_group_pair(G, edge_weight = "w", a = a, g = g )
        
        twoHopNeighborList = generate_list_of_2hop_neighbors(G, _group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
        
        inode_generator = inode_generator_5hop_src_only
        pass
    
    else:
        print("unsupported mode: ", mode)
        sys.exit(-1)
    
    total_global_links = a * g * h #one-directional links
    
    
    inodegenerator_kwargs = {"N" : a*g, 
                             "a" : a, 
                             "twoHopNeighborList" : twoHopNeighborList, 
                             "sd_pair_vs_4hop_inodes" : sd_pair_vs_4hop_inodes, 
                             "sd_pair_vs_3hop_inodes" : sd_pair_vs_3hop_inodes, 
                             #"mode_param" : mode_param
                             }
    
       
    for src_PE, dst_PE in sd_pairs:
        src_router = src_PE // p
        dst_router = dst_PE // p
        
        link_vs_usage_per_pair = {}
        
        inodes = inode_generator(src_router, dst_router, **inodegenerator_kwargs)
        
        inode_count = len(inodes)
        
        for inode in inodes:
            src_imdt_paths = vlbPathList[src_router][inode]
            imdt_dst_paths = vlbPathList[inode][dst_router]
            #print(src_imdt_paths, imdt_dst_paths)
            
            #grab each link in the first half
            path_count = len(src_imdt_paths)
            for path in src_imdt_paths:
                #print(path)
                for idx in range(len(path)-1):
                    src,dst = path[idx], path[idx+1]
                    #print(src,dst)
                    #print("inode_count, path_count", inode_count, path_count)
                    
                    #we only worry about global links
                    if _getLinkType(src,dst,a) == "global":
                        if (src,dst) not in link_vs_usage_per_pair:
                            link_vs_usage_per_pair[(src,dst)] = 1/inode_count * 1/path_count
                        else:
                            link_vs_usage_per_pair[(src,dst)] += 1/inode_count * 1/path_count
                    
            #grab each link in the second half
            path_count = len(imdt_dst_paths)
            for path in imdt_dst_paths:
                #print(path)
                for idx in range(len(path)-1):
                    src,dst = path[idx], path[idx+1]
                    #print(src,dst)
                    #print("inode_count, path_count", inode_count, path_count)
                    
                    if _getLinkType(src,dst,a) == "global":    
                        if (src,dst) not in link_vs_usage_per_pair:
                            link_vs_usage_per_pair[(src,dst)] = 1/inode_count * 1/path_count
                        else:
                            link_vs_usage_per_pair[(src,dst)] += 1/inode_count * 1/path_count
      
        total_unused_global = total_global_links - len(link_vs_usage_per_pair)
        total_used_global = len(link_vs_usage_per_pair)
        
        print("src_r {} dst_r {}  global link unused / used: {} / {}".format(src_router, dst_router, total_unused_global, total_used_global))
        
#            for link, usage in link_vs_usage_per_pair.items():
#                print(link, usage)
#    
    
    pass

def _getLinkType(src_router,dst_router,a):
    #if src and dst are in different groups, then the link is global
    src_group = src_router // a
    dst_group = dst_router // a
    if src_group != dst_group:
        return "global"
    else:
        return "local"


def process_link_usage_data(link_usage_data, *, a, h, g, p, title = None):
    '''
    link_usage_data: A dict of mode vs link_vs_usage
    
    link_vs_usage is a dict of (src,dst) vs usage (float) 
    '''
    
    totalLinks = ((a-1) + h) * a * g #one way links
#    
#    print("total, used, unused, used%, unused%: {}, {}, {}, {:.2f}%, {:.2f}%".format(totalLinks, usedLinks, unusedLinks, usedLinks/totalLinks*100, unusedLinks/totalLinks*100) )
#    
    
    data = {}
    
    for mode, link_vs_usage in link_usage_data.items():
        #sort the usages
        link_vs_usage_sorted = sorted(link_vs_usage.items(), key=operator.itemgetter(1))
        usedLinks = len(link_vs_usage)
        unusedLinks = totalLinks - usedLinks
        
        usage_values = [0.0 for x in range(unusedLinks)]
        usage_values.extend([x[1] for x in link_vs_usage_sorted])
        data[mode] = usage_values
        
    #make a dataframe
    df = pd.DataFrame(data = data)
    print("shape:", df.shape)
    #print(df.tail(20))
    
    #pass to make a chart
    #plot_lineplot(df, title)
    
    #plot_barchart(link_vs_usage_sorted, a = a, h = h, g = g, p = p)
     
    return df

    pass


def process_all_link_usage_data(all_link_usage_data):
    '''
    all_link_usage_data: A dict of (a,g,traffic,traffic_param,traffic_param_value) vs link_usage_data
    
    link_usage_data: A dict of mode vs link_vs_usage
    
    link_vs_usage is a dict of (src,dst) vs usage (float) 
    '''
    
    dataframes = {}
    
    for tup, link_usage_data in sorted(all_link_usage_data.items()):
        print(tup)
        #title = "a : {}, g : {}, traffic : {}, {} : {}".format(tup[0],tup[1],tup[2], tup[3], tup[4])
        a = tup[0]
        g = tup[1]
        h = a//2
        p = a//2
        df = process_link_usage_data(link_usage_data, a=a, h=h, g=g, p=p)
        dataframes[tup] = df
    
    plot_all_lineplots(dataframes)
    
    pass

def plot_all_lineplots(dataframes):
    '''
    dataframes: a dict of (a,g,traffic,traffic_param,traffic_param_value) vs dataframe
    '''
    sns.set(rc={'figure.figsize':(12,20)})
    
    rowCount = len(dataframes)//2
    colCount = 2    #two traffic. KISS. 
    
    fig,axes = plt.subplots(nrows = rowCount, ncols = colCount)
    
    idx = 1
    for tup, df in sorted(dataframes.items()):
        plt.subplot(rowCount, colCount, idx)
        title = "a : {}, g : {}, traffic : {}, {} : {}".format(tup[0],tup[1],tup[2], tup[3], tup[4])
        h = sns.lineplot(data = df)
        h.set(xlabel = "link", ylabel = "usage", title = title)
        idx += 1
    
    fig.tight_layout()
    
    now = datetime.datetime.now()
    a = 16
    g = 20
    routing = "combined"
    outfilename = "a_{}_g_{}_routing_{}_datetime_{}_{}_{}_{}_{}_{}.res".format(a,g,routing,now.year, now.month, now.day, now.hour, now.minute, now.second)
    print(outfilename)
    
    
    foldername = "Link_usage_graphs"
    os.makedirs(foldername, exist_ok = True)
    
    filename = "link_usage_datetime_{}_{}_{}_{}_{}_{}.png".format(now.year, now.month, now.day, now.hour, now.minute, now.second)
    
    plt.savefig(foldername + "/" + filename)
    
    pass

def plot_lineplot(df, title):
    h = sns.lineplot(data = df)
    h.set(xlabel = "link", ylabel = "usage", title = title)

def plot_barchart(link_vs_usage_sorted, *, a, h, g, p):
    totalLinks = ((a-1) + h) * a * g #one way links
    usedLinks = len(link_vs_usage_sorted)
    unusedLinks = totalLinks - usedLinks
    
    y = [0 for x in range(unusedLinks)]
    link_vs_usage_sorted_ascending = link_vs_usage_sorted[::-1]
    y.extend([x[1] for x in link_vs_usage_sorted_ascending])
    print("y len", len(y))
    
    x = [x for x in range(totalLinks) ]
    print("x len", len(x))
    
#    plt.bar(x,y, align = "center", width = 0.5)
#    plt.ylabel("usage")
#    plt.xlabel("links")
#    plt.show()
#    
    #sns.lineplot(x = x, y = y)
    plt.plot(x, y, color = "blue", marker = ".", markersize = 1, linestyle = "solid", linewidth = 1)
    
#    for elem in y[-50:]:
#        print(elem)
#    
    pass

def driverForLinkUsageCalculation():
    #create a topology
    a = 8
    gs = [9,17,25,33]
    traffics = ["rperm", "shift"]
    
    #traffic = "rperm"
    traffic_params = {"shift" : "shift_by", "rperm" : "seed"}
    traffic_param_values = {"shift" : 1, "rperm" : 45}
    
    all_usage_data = {}
    
    for g in gs:
        #g = 33
        p = a//2
        h = a//2
        arrangement = "absolute_improved"
                        #not changing it anytime soon
        G = create_topology(a,g,arrangement)
        #draw_graph_circular(G, a = a)
        
        #make the adjacency list
        graph_adj_list = generate_graph_adjacency_list(G)
        
        #make twoHopNeighborList
        group_pair_vs_global_links = get_list_of_links_between_each_group_pair(G, edge_weight = "w", a = a, g = g )
        twoHopNeighbors =  generate_list_of_2hop_neighbors(G, group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
            
        #create path list
        all_djkstra_paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
            
        #get a traffic
        #traffic = "shift"
        
        for traffic in traffics:    
            
            if traffic == "rperm":
                SDpairs = create_random_permutation_pattern(a = a, g = g, seed = traffic_param_values[traffic], verbose = False)
            elif traffic == "shift":
                SDpairs = create_shift_traffic_pattern(a = a, g = g, shift_by = traffic_param_values[traffic], router_level = False, verbose = False)
            else:
                SDpairs = None
                        
            #select a mode. Options: "src_only" or "src_and_dst"
            modes = ["src_only", "src_and_dst"]
            
            link_usage_data = {}
            
            for mode in modes:
                print("traffic:", traffic)
                print("mode:",mode)
                link_usage_data[mode] = calculateLinkUsage(graph_adj_list, SDpairs, mode, all_djkstra_paths, twoHopNeighbors, a = a, g = g, p = p)
            
            all_usage_data[(a,g,traffic,traffic_params[traffic], traffic_param_values[traffic])] = link_usage_data        
    
    
    #title = "a : {}, g : {}, traffic : {}, {} : {}".format(a,g,traffic, traffic_params[traffic], traffic_param_values[traffic])
    
    #process_link_usage_data(link_usage_data, a=a, h=h, g=g, p=p, title = "test")
    process_all_link_usage_data(all_usage_data)
    
    
#TODO: finish it
#countGlobalLinkUsage(G, sd_pairs, mode, vlbPathList, *, a, g, p, h)
def driverForGlobalLinkUsageCount():
    #create a topology
    a = 8
    gs = [9]
    traffics = ["shift"]
    
    #traffic = "rperm"
    traffic_params = {"shift" : "shift_by"}
    traffic_param_values = {"shift" : 1}
    
    for g in gs:
        #g = 33
        p = 1 #router_based traffic
        h = a//2
        arrangement = "absolute_improved"
                        #not changing it anytime soon
        G = create_topology(a,g,arrangement)
        #draw_graph_circular(G, a = a)
        
        #make the adjacency list
        graph_adj_list = generate_graph_adjacency_list(G)
        
        #make twoHopNeighborList
        group_pair_vs_global_links = get_list_of_links_between_each_group_pair(G, edge_weight = "w", a = a, g = g )
        twoHopNeighbors =  generate_list_of_2hop_neighbors(G, group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
            
        #create path list
        all_djkstra_paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
            
        #get a traffic
        #traffic = "shift"
        
        for traffic in traffics:    
            
            if traffic == "rperm":
                SDpairs = create_random_permutation_pattern(a = a, g = g, seed = traffic_param_values[traffic], verbose = False)
            elif traffic == "shift":
                SDpairs = create_shift_traffic_pattern(a = a, g = g, shift_by = traffic_param_values[traffic], router_level = True, verbose = True)
            else:
                SDpairs = None
                        
            #select a mode. Options: "src_only" or "src_and_dst"
            modes = ["3hop_paths_only", "4hop_paths_only", "5hop_src_only", "5hop_src_and_dst"]
            
            #link_usage_data = {}
            
            for mode in modes:
                print("traffic:", traffic)
                print("mode:",mode)
                #link_usage_data[mode] = calculateLinkUsage(graph_adj_list, SDpairs, mode, all_djkstra_paths, twoHopNeighbors, a = a, g = g, p = p)
                countGlobalLinkUsage(G, SDpairs, mode, all_djkstra_paths, a=a, g=g, p=p, h=h)
            
            #all_usage_data[(a,g,traffic,traffic_params[traffic], traffic_param_values[traffic])] = link_usage_data        
    
    
    pass
    
    
if __name__ == "__main__":
    print("Hello World!")
    
    #driverForLinkUsageCalculation()
    driverForGlobalLinkUsageCount()
    
    print("Bye!")