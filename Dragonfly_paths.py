#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 24 18:28:25 2019

@author: rahman

Turns out, some of the functions here are repeats from dragonfly_minpath.py
Why did I do that? I guess because I'm dumb.

"""

'''
Initially, will only contain a function that returns the list of all min-paths in a 
dragonfly network. Later, additional relevant functions can be added.
'''

import topologies
from djkstra import all_pair_all_shortest_paths_djkstra 
import sys

from itertools import combinations

def all_pair_all_min_paths_DF(Graph, group_pair_vs_global_links = None, * , edge_weight = "w", a, g, print_paths = False):
    '''
    Input:  Graph, a networkx graph object.
            edge_weight: the link property that differentiate between local and global links in DF.
                        by default, edge_wieght is set as 3 for globals and 1 for locals.
    
    Returns: A list of paths. For each src and dst, paths[src][dst] contains
        a list of tuples. Each tuple is a min path between src and dst.
    
    For Dragonfly, a min path is defined as a path that contains only one global link.
        It may not be the absolute "shortest" path in terms of hop count.
    '''
    
    '''
    Algorithm:
        1. Maintain a list of global links between each src and dst groups.
        2. For an (s,d) router pair, get the list of global links between them.
        3. For each global link, generate one path in the form of {src, link_start, link_end, dst}
        4. Repeat for each SD pair.
    '''
    
    #First, go through the graph. And generate a list of global links between each group pair.
    
    #Second, use the list of global links to generate the actual paths.
    
    if group_pair_vs_global_links is None:
        group_pair_vs_global_links = get_list_of_links_between_each_group_pair(Graph, edge_weight = "w", a = a, g = g )
    
    all_min_paths = generate_all_pair_all_min_paths_DF(group_pair_vs_global_links, a, g)
    
    if print_paths:
        print("paths generated: ")
        for src in range(a*g):
            for dst in range(a*g):
                print(src, dst, all_min_paths[src][dst])
        
    return all_min_paths

    pass

def generate_all_pair_all_min_paths_DF(group_pair_vs_global_links, a, g):
    '''
    Input: a list of global links between each src and dst groups.
    
    Returns: A list of paths. For each src and dst, paths[src][dst] contains
        a list of tuples. Each tuple is a shortest path between src and dst.

    Algorithm:
        1. For an (s,d) router pair, look up the list of global links between them.
        2. For each global link, generate one path in the form of {src, link_start, link_end, dst}
        3. Repeat for each SD pair.
    '''
    
    N = a * g
    
    paths = [ [ [] for x in range(N) ] for x in range(N) ]
    
    for src_group in range(g):
        for dst_group in range(g):
            
            #inside-group min paths
            if src_group == dst_group:
                for src in range(src_group * a, src_group * a + a):
                    for dst in range(src_group * a, src_group * a + a):
                        if src == dst:
                            continue
                        else:
                            paths[src][dst].append( (src, dst) )
            
            #outside-group min paths
            else:    
                global_links = group_pair_vs_global_links[(src_group, dst_group)]
                
                for link in global_links:
                    for src in range(src_group * a, src_group * a + a):
                        for dst in range(dst_group * a, dst_group * a + a):
                            if src == link[0] and dst == link[1]:
                                paths[src][dst].append( (src, dst) )
                            elif src == link[0]:
                                paths[src][dst].append( (src, link[1], dst) )
                            elif dst == link[1]:
                                paths[src][dst].append( (src, link[0], dst) )
                            else:
                                paths[src][dst].append( (src, link[0], link[1], dst) )
        
    return paths
    
    pass


def get_list_of_links_between_each_group_pair(Graph, * , edge_weight = "w", a, g):
    '''
    Input:  Graph, a networkx graph object.
            edge_weight: the link property that differentiate between local and global links in DF.
                        by default, edge_weight is set as 3 for globals and 1 for locals.
    
    Output: 
        A dict of key: (src_group,dst_group), val: list of global links. Each element in the list is a (src,dst) tuple.
    
    '''
    
    group_pair_vs_global_links = {}
    
    for edge in Graph.edges(data = True):
        #print(edge)
        src = edge[0]
        dst = edge[1]
        weight = edge[2][edge_weight]
        #print("src, dst, weight:", src, dst, weight)
        
        if weight == 3:
            src_group = src // a
            dst_group = dst // a
            if (src_group, dst_group) not in group_pair_vs_global_links:
                group_pair_vs_global_links[(src_group, dst_group)] = [(src, dst)]
                group_pair_vs_global_links[(dst_group, src_group)] = [(dst,src)]
            else:
                group_pair_vs_global_links[(src_group, dst_group)].append( (src, dst) )
                group_pair_vs_global_links[(dst_group, src_group)].append( (dst,src) )
                
#    for src_group in range(g):
#        for dst_group in range(g):
#            if src_group != dst_group:
#                print(src_group, dst_group, group_pair_vs_global_links[(src_group, dst_group)])
#        
    return group_pair_vs_global_links

    pass

def generate_list_of_2hop_neighbors(Graph, group_pair_vs_global_links, *, edge_weight = "w", a, g):
    '''
    Returns a 2-D list lst. 
    lst[src] => a list of nodes that can be reached in one or two hops from the src.
    
    Does not include same-group neighbors.
    '''
    '''
    For a node, all node that are connected to it by two hops are the nodes:
        a) nodes in the groups connected to the source node by a global link 
        b) nodes connected by global links from the neighbor nodes in the same group as the source node.
        
    Logic:
        - Allocate the data structures
        - Go through all the global links (we have a data structure that stores them).
        - For each global link, get the src and dst 
            - For the src, list all the nodes in the dest's group as two-hop neighbors.
            - Add the src to the list of all dest_group_neighbors.
            - For the dst, list all the nodes in the src's group as the two-hop neighbors.
            - Add the dst to the list of all src_group_neighbors.
            
            
        - After the sets are populated, generate the vectors.
    '''
    
    
    N = a * g
    
    twoHopNeighbor_sets = [ set() for x in range(N) ]
    
    #    print("All neighbor list:")
    #    for node in Graph.nodes():
    #        print(node, " : ", end = " ")
    #        for neighbor in Graph.neighbors(node):
    #            print(neighbor, end = " ")
    #        print()

    count = 0
    for edge in Graph.edges(data = True):
        if edge[2][edge_weight] == 3:    #global link
            src = edge[0]
            dst = edge[1]
            src_group = src // a
            dst_group = dst // a
            
            # For the src, list all the nodes in the dest's group as two-hop neighbors.
            # Add the src to the list of all dest_group_neighbors.
            for neighbor in range(dst_group*a, dst_group*a + a):
                twoHopNeighbor_sets[src].add(neighbor)
                twoHopNeighbor_sets[neighbor].add(src)
            
            # For the dst, list all the nodes in the src's group as the two-hop neighbors.
            # Add the dst to the list of all src_group_neighbors.
            for neighbor in range(src_group*a, src_group*a + a):
                twoHopNeighbor_sets[dst].add(neighbor)
                twoHopNeighbor_sets[neighbor].add(dst)
            
    twoHopNeighbors = [list(x) for x in twoHopNeighbor_sets]

#    print("two hop neighbors:")
#    for idx,lst in enumerate(twoHopNeighbors):
#        print(idx, lst)

                
    #quickly check if the results are correct
#    import djkstra
#    src = 35
#    paths_dj = djkstra.all_pair_all_shortest_paths_djkstra(G, print_paths = False)
#    
#    for dst in range(N):
#        print(src, dst, paths_dj[src][dst])
#        
#    
    return twoHopNeighbors
            
    pass


def generate_list_of_nodes_connected_to_group_pairs(graph_adj_list, a):
    
    #print("inside generate_list_of_nodes_connected_to_group_pairs()")
    
    group_pair_vs_nodes = {}
    
    for idx in range(len(graph_adj_list)):
        neighbors = graph_adj_list[idx]
        #print(idx, neighbors)        
        #need all the combinations of length 2
        combos = combinations(neighbors[a-1:],2)
        for src, dst in combos:
            src_group = src // a
            dst_group = dst // a
            
            #print(src,dst,src_group, dst_group)
            
            if (src_group, dst_group) not in group_pair_vs_nodes:
                group_pair_vs_nodes[(src_group, dst_group)] = [idx]
            else:
                group_pair_vs_nodes[(src_group, dst_group)].append(idx)
            
            if (dst_group, src_group) not in group_pair_vs_nodes:
                group_pair_vs_nodes[dst_group, src_group] = [idx]
            else:
                group_pair_vs_nodes[dst_group, src_group].append(idx)
            
            
    #    for pair, node in sorted(group_pair_vs_nodes.items()):
    #        print(pair, node)
    #        
    #    print("returning from generate_list_of_nodes_connected_to_group_pairs()")
    #        
    return group_pair_vs_nodes

    pass

def get_inodes_for_4hop_paths(src, dst, Graph, graph_adj_list, group_pair_vs_nodes, *, edge_weight = "w", a, g):
    
    '''
    Output: A list of candidate i-nodes.
    
    Logic:
        1. Get the global links connected to src. Get their other ends.
        2. get the global links connected to dst. Get their other ends.
        3. Lookup to see if there is any node that has global links to both src and dst groups.
            If there exists one, pick that one up.
    '''
    
    '''
    This needs to be done for each S-D pair. 
    One option is to pre-process it. In that case, what is the space requirement?
    
    total pairs: N * (N-1)
    For a8 g33, N = 33 * 8 = 264
    So total SD pairs: 69K
    
    Each pair will have at least h + h  = 8 nodes.
    let's assume another 8 for each pair.
    So, each pair need to hold a vector of 16 nodes.
    
    Total size: 69K * 16 = 1.1 M ~ 8 M for int.
    Hardly a problem.
    
    Also, DF is symmetric. So instead of each pair, save only half of it (s,d when s < d).
    
    The other option is caching. Save it in a map. As space isn't a problem, let's just use an unordered_map.
    LRU cache would be an overkill.
    
    '''
    
    res = set()
    
    src_group = src // a
    dst_group = dst // a
    
    # 1. Get the global links connected to src. Get their other ends.
    src_neighbor_list = graph_adj_list[src]
    for idx in range(a-1, len(src_neighbor_list)):
        #if it not in dst's group already
        if (src_neighbor_list[idx] // a) != dst_group:
            res.add(src_neighbor_list[idx])
        
    # 2. get the global links connected to dst. Get their other ends.  
    dst_neighbor_list = graph_adj_list[dst]
    for idx in range(a-1, len(dst_neighbor_list)):
        if (dst_neighbor_list[idx] // a) != src_group:
            res.add(dst_neighbor_list[idx])
        
    # 3. Lookup to see if there is any node that has global links to both src and dst groups.
    # If there exists one, pick that one up.
    if (src_group, dst_group) in group_pair_vs_nodes:
        for node in group_pair_vs_nodes[(src_group, dst_group)]:
            #if the node is not part of src or dst's group
            if (node // a) != src_group and (node // a) != dst_group:
                res.add(node)
        
    res = sorted(list(res))
    
    #print("src, dst, four hop inodes: ",src, dst, res)
    
    
    return res
    
    pass


def get_inodes_for_3hop_paths(src_router, dst_router, Graph, graph_adj_list, two_hop_neighbor_list, *, edge_weight = "w", a, g):
    
    '''
    Output: A list of candidate i-nodes.
    
    Logic:
        1. Get the 2-hop neighbors of src. See any of them are directly connected to dst. If yes, and not in dst's group,  add as a candidate.
        2. Get the 2-hop neighbors of dst. See any of them are directly connected to src. If yes, and not in src's group, add as a candidate.
        
    '''
    
    
    res = set()
    
    src_group = src_router // a
    dst_group = dst_router // a
    #print("src, dst,src_group, dst_group", src_router, dst_router, src_group, dst_group)
    
    #print(src_router, dst_router)
    
    src_neighbor_set = set(graph_adj_list[src_router][a-1 :])
    #print("src neighbors:", src_neighbor_set)
    
    dst_neighbor_set = set(graph_adj_list[dst_router][a-1:])
    #print("dst neighbors:", dst_neighbor_set)
    
    src_2hop_neighbors = two_hop_neighbor_list[src_router]
    #print("src_2hop_neighbors:", src_2hop_neighbors)
    
    for node in src_2hop_neighbors:
        if node//a != dst_group:
            if node in dst_neighbor_set:
                res.add(node)
                
    
    dst_2hop_neighbors = two_hop_neighbor_list[dst_router]
    #print("dst_2hop_neighbors:", dst_2hop_neighbors)
    
    for node in dst_2hop_neighbors:
        if node//a != src_group:
            if node in src_neighbor_set:
                res.add(node)
    
    #print("3hop inodes:", res)
    
    # 1. Get the global links connected to src. Get their other ends.
#    src_neighbor_list = graph_adj_list[src]
#    for idx in range(a-1, len(src_neighbor_list)):
#        #if it not in dst's group already
#        if (src_neighbor_list[idx] // a) != dst_group:
#            res.add(src_neighbor_list[idx])
#        
#    # 2. get the global links connected to dst. Get their other ends.  
#    dst_neighbor_list = graph_adj_list[dst]
#    for idx in range(a-1, len(dst_neighbor_list)):
#        if (dst_neighbor_list[idx] // a) != src_group:
#            res.add(dst_neighbor_list[idx])
#        
#    # 3. Lookup to see if there is any node that has global links to both src and dst groups.
#    # If there exists one, pick that one up.
#    if (src_group, dst_group) in group_pair_vs_nodes:
#        for node in group_pair_vs_nodes[(src_group, dst_group)]:
#            #if the node is not part of src or dst's group
#            if (node // a) != src_group and (node // a) != dst_group:
#                res.add(node)
#        
#    res = sorted(list(res))
#    
    #print("src, dst, four hop inodes: ",src, dst, res)
    
    
    return sorted(list(res))
    
    pass





def inodes_for_4hop_paths_for_all_SD_pairs(traffic, Graph, graph_adj_list,  group_pair_vs_nodes, *, edge_weight = "w", a, g, p):
    '''
    Set p = 1 if dealing with router level traffic.
    
    Traffic is a list of (src_pe, dst_pe) tuples.
    
    Returns a dict of (src_router,dst_router) vs [list of inodes_for_4hop_paths for the pair] 
    '''
    
    sd_pair_vs_4hop_inodes = {}
    
    for (src_pe, dst_pe) in traffic:
        if src_pe == dst_pe:
            continue
        
        src_router = src_pe // p
        dst_router = dst_pe // p
        
        if (src_router, dst_router) in sd_pair_vs_4hop_inodes:
            continue
        
        elif (dst_router, src_router) in sd_pair_vs_4hop_inodes:
            sd_pair_vs_4hop_inodes[(src_router, dst_router)] = sd_pair_vs_4hop_inodes[(dst_router, src_router)] 
        
        else:
            inodes = get_inodes_for_4hop_paths(src_router, dst_router, Graph, graph_adj_list,  group_pair_vs_nodes, edge_weight = "w", a = a, g = g)
            sd_pair_vs_4hop_inodes[(src_router, dst_router)] = inodes
    
    return sd_pair_vs_4hop_inodes
    
    pass

def inodes_for_3hop_paths_for_all_SD_pairs(traffic, Graph, graph_adj_list,  two_hop_neighbor_list, *, edge_weight = "w", a, g, p):
    '''
    Set p = 1 if dealing with router level traffic.
    
    Traffic is a list of (src_pe, dst_pe) tuples.
    
    Returns a dict of (src_router,dst_router) vs [list of inodes_for_4hop_paths for the pair] 
    '''
    
    sd_pair_vs_3hop_inodes = {}
    
    for (src_pe, dst_pe) in traffic:
        if src_pe == dst_pe:
            continue
        
        src_router = src_pe // p
        dst_router = dst_pe // p
        
        if (src_router, dst_router) in sd_pair_vs_3hop_inodes:
            continue
        
        elif (dst_router, src_router) in sd_pair_vs_3hop_inodes:
            sd_pair_vs_3hop_inodes[(src_router, dst_router)] = sd_pair_vs_3hop_inodes[(dst_router, src_router)] 
        
        else:
            inodes = get_inodes_for_3hop_paths(src_router, dst_router, Graph, graph_adj_list,  two_hop_neighbor_list, edge_weight = "w", a = a, g = g)
            sd_pair_vs_3hop_inodes[(src_router, dst_router)] = inodes
    
    return sd_pair_vs_3hop_inodes
    
    pass

def get_inodes_for_4hop_paths_version_2(src, dst, two_hop_neighbor_list):
    
    '''
    This one gets more i-nodes, but some of the i-nodes uses the same global link.
    So this will disporportionately use global links.
    So we shoudl stick with the top one.
    '''
    
    print("inside get_inodes_for_4hop_paths_version_2()")
    
    print(src, two_hop_neighbor_list[src])
    print(dst, two_hop_neighbor_list[dst])
    
    src_neighbors = set(two_hop_neighbor_list[src])
    dst_neighbors = set(two_hop_neighbor_list[dst])
    
    two_hop_neighbors = sorted(list(src_neighbors & dst_neighbors))
    
    print(two_hop_neighbors)
    
    print("leaving get_inodes_for_4hop_paths_version_2()")
    
    return two_hop_neighbors

    pass


def generate_graph_adjacency_list(G, * , edge_weight = "w", verbose = False):
    
    N = len(G)
    
    #    print("total nodes:", N)
    #    
    #    print("total local links:", len(local_links))
    #    print("total global links:", len(global_links))
    #    
    #    graph_adj_list = [ [] for x in range(N)]
    #    
    #    for (src,dst) in local_links:
    #        graph_adj_list[src].append(dst)
    #    
    #    for (src,dst) in global_links:
    #        graph_adj_list[src].append(dst)
    #    
    #    for idx,neighbors in enumerate(graph_adj_list):
    #        print(idx, neighbors)
        
    #alternate way by using only the Graph object
    graph_adj_list_local = [ [] for x in range(N)]
    graph_adj_list_global = [ [] for x in range(N)]
    graph_adj_list_full = [ [] for x in range(N)]
    
    for edge in G.edges(data = True):
        #print(edge)
        src = edge[0]
        dst = edge[1]
        weight = edge[2][edge_weight]
        #print("src, dst, weight:", src, dst, weight)
        
        if weight == 3:
            graph_adj_list_global[src].append(dst)
            graph_adj_list_global[dst].append(src)
        elif weight == 1:
            graph_adj_list_local[src].append(dst)
            graph_adj_list_local[dst].append(src)
        else:
            print("Error. Invalid link weight:", weight)
            sys.exit(-1)
        
    for idx in range(N):
        graph_adj_list_full[idx] = graph_adj_list_local[idx] + graph_adj_list_global[idx] 
    
    if verbose:
        for idx in range(N):
            print(idx, graph_adj_list_full[idx])
    
    return graph_adj_list_full
    
    pass

def generate_djkstra_vlb_path(src, imdt, dst, all_pair_djkstra_paths):
    
    src_imdt_paths = all_pair_djkstra_paths[src][imdt]
    imdt_dst_paths = all_pair_djkstra_paths[imdt][dst]
    
    complete_paths = []
    for path1 in src_imdt_paths:
        for path2 in imdt_dst_paths:
            complete_path = list(path1) + list(path2)[1:] 
            complete_paths.append(complete_path)
    
    print("imdt:", imdt, end = " ")
    print(src_imdt_paths, end = " ")
    print(imdt_dst_paths, end = " ")
    print(complete_paths, end = " ")
    print("hops", len(complete_paths[0]) - 1)
    
    return complete_path
    
    pass


if __name__ == "__main__":
    
    from test_jains_and_mcf import draw_graph_circular

    print("Hello world!")
    
    
    a = 4
    g = 5
    p = a//2
    arrangement = "absolute_improved"
    
    #G = create_topology(a,g,arrangement)
    G, local_links, global_links = topologies.build_drgonfly(a=a, p=a // 2, h=a // 2, gl_arrangmnt=arrangement, g=g, seed = 0)
    
    graph_adj_list = generate_graph_adjacency_list(G)
    
    group_pair_vs_global_links = get_list_of_links_between_each_group_pair(G, edge_weight = "w", a = a, g = g )
    
    paths_dj = all_pair_all_shortest_paths_djkstra(G, print_paths = False)
    
    group_pair_vs_nodes = generate_list_of_nodes_connected_to_group_pairs(graph_adj_list, a)
    
    two_hop_neighbor_list = generate_list_of_2hop_neighbors(G, group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
    
    from traffic import create_random_permutation_pattern
    SDpairs = create_random_permutation_pattern(a = a, g = g, seed = 10, verbose = False)
    
    print("\nTraffic pattern:")
    
    sd_pair_vs_3hop_inodes = inodes_for_3hop_paths_for_all_SD_pairs(SDpairs, G, graph_adj_list, two_hop_neighbor_list, edge_weight = "w", a = a, g = g, p = p)
    
    for pair in SDpairs:
        src = pair[0]
        dst = pair[1]
        src_router = src//p
        dst_router = dst//p
        if src == dst:
            continue
        inodes = sd_pair_vs_3hop_inodes[(src_router, dst_router)]
        
        print("\n",src,dst," : ", src_router, dst_router, " : ", inodes)
        for imdt in inodes:
            path = generate_djkstra_vlb_path(src_router, imdt, dst_router, paths_dj)



#    src = 0
#    dst = 9
#    four_hop_inodes = get_inodes_for_4hop_paths(src, dst, G, graph_adj_list, group_pair_vs_global_links, group_pair_vs_nodes, edge_weight = "w", a = a, g = g)
#
#    print("\ntesting the paths generated this way:")
#    for imdt in four_hop_inodes:
#        path = generate_djkstra_vlb_path(src, imdt, dst, paths_dj)
#
#    four_hop_inodes_2 = get_inodes_for_4hop_paths_version_2(src, dst, two_hop_neighbor_list)
#
#    print("\ntesting the paths generated this way:")
#    for imdt in four_hop_inodes_2:
#        path = generate_djkstra_vlb_path(src, imdt, dst, paths_dj)
#        
    


#    
#    two_hop_neighbors = generate_list_of_2hop_neighbors(G, group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
#    
#    print("two hop neighbors of", src)
#    neighbors = two_hop_neighbors[src]
#    print(sorted(neighbors))
#    print("total:", len(neighbors))
#    
#    for imdt in four_hop_inodes:
#        path = generate_djkstra_vlb_path(src, imdt, dst, paths_dj)
#    
    
#    for pair, lst in sorted(group_pair_vs_global_links.items()):
#        print(pair, lst)
    
    #all_pair_all_min_paths_DF(G, edge_weight = "w", a = a, g = g)
    
    #twoHopeNeighbors = generate_list_of_2hop_neighbors(G, group_pair_vs_global_links, a = a, g = g)
    
#    for idx,lst in enumerate(twoHopeNeighbors):
#        print(idx,lst)
#    
    
    draw_graph_circular(G, a = a)
    print("Done!")