#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Feb 11 11:25:55 2018

@author: Zaid & Gene
"""
import importlib.util
import sys
import pip

import time

#result = 1 
#packages_list = ['nxmetis','networkx','itertools','sklearn','pandas','colorama','tqdm','argparse','numpy']     
#for package_name in packages_list:
#         spec = importlib.util.find_spec(package_name)
#         if spec is None:
#             print(package_name +" is not installed")
#             result = 0    
#
#if not result:
#    print("please run 'sudo sh setup.sh ' to install the required packeges\n")
#    exit(1)
    

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
from sklearn.neighbors import KernelDensity
import pandas as pd
from sklearn.preprocessing import scale
import subprocess
import re
import datetime
import math
from itertools import permutations, combinations
import random
import copy
import operator
from networkx.algorithms import community
from collections import deque
import nxmetis
from colorama import Fore, Back, Style
from tqdm import tqdm
import argparse
import itertools
import global_links_arrangment as gl

style_Flag = False

path = "/home/oem/Dropbox/area/booksim/src/"

def run_booksim():
    # filename = input("File name: ")
    filename = 'examples/df'

    rate = 0.01

    def pInject(line):
        pInject.rate += rate
        return line[:line.index('=') + 1] + str(pInject.rate) + line[line.index(';'):]

    pInject.rate = 0.10

    for filename in ['examples/df', 'examples/anynet/df']:
        run = True
        # print(filename)
        perams = [['injection_rate', pInject]]
        while run:
            newFile = ""
            for line in open(path + filename, 'r'):
                for match, funct in perams:
                    if match in line:
                        line = funct(line)
                newFile += line

            with open(path + filename, 'w') as fd:
                fd.write(newFile)

            cmdName = path + 'booksim'
            proc = subprocess.run([cmdName, path + filename], stdout=subprocess.PIPE)
            # print("saturated at ",pInject.rate)
            bookOut = proc.stdout.decode('utf-8')
            if 'Aborting simulation' in bookOut:
                run = False
                pInject.rate = 0.10
                print("saturated at %.2f " % (pInject.rate - 0.01))
                break


'''
write a topology in booksim format
'''


def write_adj_list_to_a_file_booksim(G, name, h):
    nodes = sorted(list(G.nodes()))
    # print(nodes)
    server_count = 0
    name = path + "examples/anynet/" + str(name)
    with open(name, 'w') as fd:

        for node in nodes:
            fd.write("router " + str(node) + " ")

            for i in range(h):
                fd.write("node " + str(server_count) + " ")
                server_count += 1
            # fd.write("\n")

            for n in sorted(list(G.neighbors(node))):
                fd.write("router " + str(n) + " ")
            fd.write("\n")


'''
get the degree with a redundent links
'''


def get_degree(G, sw, global_links):

    neighburs_list = list(G.neighbors(sw))

    degree = 0

    for n in neighburs_list:
        d1 = d2 = 0
        if (sw, n) in global_links and G[sw][n]['type'] == 'global':
            d1 = global_links[(sw, n)]
        if (n, sw) in global_links and G[sw][n]['type'] == 'global':
            d2 = global_links[(n, sw)]
        degree += max(d1, d2)
    # print("nx degree: ",G.degree(sw)," our degree : ",degree)
    return degree
'''
get the degree with a redundent links
'''


def get_degree_global(G, sw, global_links):

    neighburs_list = list(G.neighbors(sw))

    degree = 0

    for n in neighburs_list:
        d1 = d2 = 0
        if (sw, n) in global_links:
            d1 = global_links[(sw, n)]
        if (n, sw) in global_links:
            d2 = global_links[(n, sw)]
        degree += max(d1, d2)
    # print("nx degree: ",G.degree(sw)," our degree : ",degree)
    return degree

def get_degree_global2(G, sw, global_links):

    neighburs_list = list(G.neighbors(sw))

    degree = 0

    for n in neighburs_list:
        d1 = d2 = 0
        if (sw, n) in global_links:
            d1 = global_links[(sw, n)]['w']
        if (n, sw) in global_links:
            d2 = global_links[(n, sw)]['w']
        degree += max(d1, d2)
    # print("nx degree: ",G.degree(sw)," our degree : ",degree)
    return degree

def get_balance_condition(a, h, g):
    t = (a * h) / (g - 1)
    alpha = (t * (g - 1)) / (a * (a - 1))
    b = 1 + (alpha * ((a * (a - 1)) / t))
    print("t = ", t, "alpha = ", alpha, "b = ", b)
    return t
    # print("t = ", t, "alpha = ", alpha, "b = ", b)


'''
A simple safety check after a topology is connected.
According to DF spec, each node has h number of global ports.
Means, each link should have max h in-degree and max h out-degree.
This fuction will return False if any node supercedes that limit.
'''
def global_links_degree_check(global_links, a, h, g):
    
    total_nodes = a * g
    
    in_degrees = [0 for x in range(total_nodes)]
    out_degrees = [0 for x in range(total_nodes)]
    
    for link,attributes in global_links.items():
        out_degrees[link[1]] += attributes["w"]
        in_degrees[link[0]] += attributes["w"]
    
    print("in_degrees:", in_degrees)
    print("out_degrees:", in_degrees)
    
    violated = False
    for idx,x in enumerate(in_degrees):
        if x > h:
            print("in_degree violated for node", idx, ":",h)
            violated = True
    for idx,x in enumerate(out_degrees):
        if x > h:
            print("out_degree violated for node", idx, ":",h)
            violated = True
    
    if violated is False:
        print("All links pass node-degree test.")
    
    pass


'''
global links arrangments for the global links 
'''
#this logic seems overly complicated. Replaced downunder.

#def arrang_global_link_smart(G, g, a, h, name, local_links):

    #print("starting arrang_global_link_smart. g, a, h, name,", g,a,h,name)
    
    
    
    #    s_d_list = gl.global_links_arrangment(name,a,g,h)
    #    global_links = {}
    #    
    #    for src,dest in s_d_list:
    #        #print(src,dest)
    #        #if G.has_edge(src, dest) and (src,dest) == (39,18):
    #        #    print(src,dest,G.get_edge_data(src,dest))
    #        
    #        if G.has_edge(src, dest):
    #            if (src,dest) == (39,18):
    #                print("edge present in graph: ",src,dest,G.get_edge_data(src,dest))
    #            
    #            if (src, dest) in global_links:
    #                
    #                if (src,dest) == (39,18):
    #                    print("edge 39,18 present in global_links: ",global_links)
    #            
    #                
    #                G[src][dest]['dire'][(src, dest)] += 1
    #                G[src][dest]['wight'] += 1
    #                global_links[(src, dest)] += 1
    #                
    #                
    #            else:
    #                if (src,dest) == (39,18):
    #                    print("edge 39,18 not present in global_links: ",global_links)
    #                global_links[(src, dest)] = 1
    #                if (src,dest) == (39,18):
    #                    print("edge 39,18 added in global_links: ",global_links)
    #            
    #                
    #        else:
    #            if (src,dest) == (39,18):
    #                print("edge not present. Add it for the first time.")
    #            
    #            global_links[(src, dest)] = 1
    #            if (src,dest) == (39,18):
    #                print("global_links:", global_links)
    #            G.add_edge(src, dest, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
    #                       dire={(src, dest): 1})
    #            if (src,dest) == (39,18):
    #                print("Edge added: ",src,dest,G.get_edge_data(src,dest))
    #    temp = dict()
    #
    #    for switch, connect_to in list(G.edges()):
    #        if G[switch][connect_to]['type'] == 'global':
    #
    #            if (switch, connect_to) in global_links:
    #                t1 = global_links[(switch, connect_to)]
    #            else:
    #                t1 = 0
    #
    #            if (connect_to, switch) in global_links:
    #                t2 = global_links[(connect_to, switch)]
    #            else:
    #                t2 = 0
    #
    #            max_w = max(t1, t2)
    #
    #            for link in [(switch, connect_to), (connect_to, switch)]:
    #                temp[link] = dict()
    #                temp[link]['w'] = max_w  # G[switch][connect_to]['wight']
    #                temp[link]['load'] = 0
    #                temp[link]['count'] = 0
    #            
    #    global_links = temp
    #    return G, global_links

def arrang_global_link_smart(G, g, a, h, name, local_links):

    s_d_list = gl.global_links_arrangment(name,a,g,h)
        #this returns the list of all the unidirectional Global links.
        
    # go though every unidirectional global link, and save its weight 
    g_link_weight = {}
    
    for (s,d) in s_d_list:
        if (s,d) not in g_link_weight:
            g_link_weight[(s,d)] = 1
        else:
            g_link_weight[(s,d)] += 1
    
    #go through it again. For each link, get the max weight out of each direction.
    g_link_weight_bidirecitonal = {}
    
    for ((s,d), weight) in g_link_weight.items():
        
        if (d,s) not in g_link_weight_bidirecitonal:                
            #this is because we want to have only one entry for a bidirectional link.
                #so picking only one direction out of two
                
            weight1 = weight
            if (d,s) in g_link_weight:
                weight2 = g_link_weight[(d,s)]
            else:
                weight2 = 0
            final_weight = max(weight1, weight2)
            
            g_link_weight_bidirecitonal[(s,d)] = (final_weight,weight1, weight2)
                
    
    global_links = {}
    
    #now add all the global links into the graph
    for ((s,d),(max_weight, weight1, weight2)) in g_link_weight_bidirecitonal.items():
        G.add_edge(s, d, type="global", color=(0.0, 0.0, 1.0), w=3, wight=max_weight, dire={(s, d): weight1, (d,s): weight1})
        
        global_links[(s,d)] = {'w': max_weight, 'load': 0, 'count': 0 }
        global_links[(d,s)] = {'w': max_weight, 'load': 0, 'count': 0 }
    
        #IMPORTANT !!!
        #This can be confusing, but global_links[link]["w"] is equivalent to the 
        #"wight" property in the Graph, NOT the "w" property in Graph which is totally different.
    
    #    if (len(G.nodes) > a*g):
    #        print(Fore.RED)
    #        print("Number of nodes is greater than a * g. node_count: {}, a: {}, g: {}".format(a*g, a, g))
    #        print(Style.RESET_ALL)
    #        
    #    global_links_degree_check(global_links, a, h, g)

    return G, global_links

#
# def arrang_global_link_smart(G, g, a, h, gl_arrangmnt, local_links):
#
#     assert (a % 2 == 0)
#     degree = G.degree(0) + h
#
#     global_links = {}
#     ops = {"+": operator.add,
#            "-": operator.sub}
#
#     if gl_arrangmnt == 'absolute':
#         for j in range(g):
#             for i in range(a):
#                 for k in range(h):
#                     x = i * h + k
#                     if x < j:
#                         ds = (j - 1) // h
#                     else:
#                         ds = j // h
#                         x += 1
#
#                     #print("(", i, ",", j, ")", "->", "(", ds, ",", x % g, ")")
#
#                     switch = (j * a) + i
#                     next_g = x % g
#                     connect_to = (a * next_g) + ds
#
#
#                     if G.has_edge(switch, connect_to):
#                         # print(switch , connect_to)
#                         if (switch, connect_to) in global_links:
#                             G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                     else:
#                         global_links[(switch, connect_to)] = 1
#                         G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                    dire={(switch, connect_to): 1})
#
#
#     elif gl_arrangmnt == 'relative':
#         swithes = [[x + y for y in range(a // 2)] for x in range(0, g * a, a // 2)[::2]]
#
#         for switch_list in swithes:
#             for switch in switch_list:
#                 g_id = switch // a
#                 s_id = switch % a
#                 # print(switch, ':', g_id, s_id)
#
#                 loop = 0
#                 for next_g in range(g_id + (s_id * h) + 1, g_id + (s_id * h) + h + 1):
#                     # connect to nodes in the next h groups
#                     # print(next_g)
#                     if (next_g + loop) % g == g_id:
#                         loop += 1
#                     next_g = (next_g + loop) % g
#                     next_s = a - s_id
#                     connect_to = (next_g * a) + next_s - 1
#
#                     if G.has_edge(switch, connect_to):
#                         # print(switch , connect_to)
#                         if (switch, connect_to) in global_links:
#                             G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                     else:
#                         global_links[(switch, connect_to)] = 1
#                         G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                    dire={(switch, connect_to): 1})
#
#
#
#     elif gl_arrangmnt == 'relative_improved':
#         swithes = [[x + y for y in range(a // 2)] for x in range(0, g * a, a // 2)[::2]]
#
#         for switch_list in swithes:
#             for switch in switch_list:
#                 g_id = switch // a
#                 s_id = switch % a
#                 # print(switch, ':', g_id, s_id)
#
#                 loop = 0
#                 for next_g in range(g_id + (s_id * h) + 1, g_id + (s_id * h) + h + 1):
#                     # connect to nodes in the next h groups
#                     print(next_g)
#                     if (next_g + loop) % g == g_id:
#                         loop += 1
#                     next_g = (next_g + loop) % g
#                     next_s = a - s_id
#                     connect_to = (next_g * a) + next_s - 1
#                     # print(g_id, s_id)
#                     print("(1)switch :",switch,"(",s_id,",",g_id,")","->","(",next_s,",",next_g,") , switch :" ,connect_to)
#
#                     if G.has_edge(switch, connect_to):
#                         # print(switch , connect_to)
#                         if (switch, connect_to) in global_links:
#                             G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                     else:
#                         global_links[(switch, connect_to)] = 1
#                         G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                    dire={(switch, connect_to): 1})
#     # elif gl_arrangmnt == 'abslute':
#     #     '''
#     #         2- absolute
#     #         (i,j) connect to jh + k if jk + k < i
#     #                          jh + k + 1 otherwise
#     #         i = group id
#     #         j = switch id in the group
#     #         k = link count
#     #     '''
#     #     for switch in list(G.nodes()):
#     #         g_id = int(switch / a)
#     #         s_id = int(switch % a)
#     #
#     #         for k in range(h):
#     #             # k %= g
#     #             # connect to nodes in the next h groups
#     #             dest_group = ((s_id * h) + k) % g
#     #
#     #             if dest_group < g_id:
#     #                 dest_sw = (g_id - 1) // h
#     #             else:
#     #                 dest_group += 1
#     #                 dest_sw = (g_id // h)
#     #
#     #             connect_to = (dest_group * a) + dest_sw
#     #             #g_port = (switch % a) * h + h
#     #
#     #
#     #
#     #             if G.has_edge(switch, connect_to):
#     #                 # print(switch , connect_to)
#     #                 if (switch, connect_to) in global_links:
#     #                     G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#     #                     G[switch][connect_to]['wight'] += 1
#     #                     global_links[(switch, connect_to)] += 1
#     #                 else:
#     #                     global_links[(switch, connect_to)] = 1
#     #             else:
#     #                 global_links[(switch, connect_to)] = 1
#     #                 G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#     #                            dire={(switch, connect_to): 1})
#
#
#
#     elif gl_arrangmnt == 'consecutive':  # abslote
#
#         t = (h * a) // (g - 1)
#         shift = 0
#         swithes = [[x + y for y in range(a // 2)] for x in range(0, g * a, a // 2)[::2]]
#
#         for switch_list in swithes:
#             for switch in switch_list:
#                 g_id = switch // a
#                 s_id = switch % a
#                 # print(switch, ':', g_id, s_id)
#
#                 loop = 0
#                 for next_g in (g_id + 1 for _ in range(g_id + (s_id * h) + 1, g_id + (s_id * h) + h + 1)):
#                     # connect to nodes in the next h groups
#                     # print(next_g)
#                     while (next_g + loop) % g == g_id:
#                         loop += 1
#                     next_g = (next_g + loop) % g
#                     next_s = s_id
#                     connect_to = (next_g * a) + next_s
#                     # print(g_id, s_id)
#                     #print("(1)switch :",switch,"(",s_id,",",g_id,")","->","(",next_s,",",next_g,") , switch :" ,connect_to)
#
#                     if G.has_edge(switch, connect_to):
#                         # print(switch , connect_to)
#                         if (switch, connect_to) in global_links:
#                             G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                         else :
#                             global_links[(switch, connect_to)] = 1
#                     else:
#                         global_links[(switch, connect_to)] = 1
#                         G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                    dire={(switch, connect_to): 1})
# #        print(t)
# #        # get_balance_condition(a,h,g)
# #        n = G.number_of_nodes()
# #
# #        for gSrc in range(g):
# #            shif = 0
# #            count = 0
# #            for sSrc in range(a):
# #                if count == gSrc:
# #                    count += 1
# #                    continue
# #                for k in range(0, h, t):
# #
# #                    print("ok")
# #                    if count % g == 0:
# #                        shift += 1
# #
# #                    gDst = (gSrc + count) % g
# #                    if gDst < gSrc:
# #                        sDst = (gSrc - 1) // h
# #
# #                    else:
# #                        sDst = gSrc // h
# #                        # gDst += 1
# #                        # sDst = gSrc + shift
# #                    sDst += shift
# #                    count += 1
# #                    switch = (gSrc * a) + sSrc
# #                    connect_to = ((gDst * a) + sDst) % n
# #
# #                    print(gSrc, sSrc, gDst, sDst, shift)
# #                    if get_degree(G, switch, global_links) >= h or get_degree(G, connect_to, global_links) >= h:
# #                        continue
# #
# #                    if G.has_edge(switch, connect_to):
# #                        # print(switch , connect_to)
# #
# #                        if (switch, connect_to) in global_links:
# #                            # G[switch][connect_to]['dire'][(switch, connect_to)] += 1
# #                            G[switch][connect_to]['wight'] += t
# #                            global_links[(switch, connect_to)] += t
# #                        else:
# #                            global_links[(switch, connect_to)] = t
# #                    else:
# #                        global_links[(switch, connect_to)] = t
# #                        G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=t,
# #                                   dire={(switch, connect_to): 1})
#     elif gl_arrangmnt == 'consecutive2':
#        # print('ok')
#
#         t = (h * a) // (g - 1)
#
#         for switch in range(G.number_of_nodes()):
#             j = switch // a
#             i = (switch % a)
#             for k in range(0, h, t):
#
#                 next_g = ((i * h) + k) % g
#
#                 if next_g < j:
#                     next_s = (j - 1) // h
#
#                 else:
#                     next_s = j // h
#                     next_g += 1
#
#                 next_g %= g
#                 # next_s
#
#                 #                print(i,j,next_g, (next_s + shift) % G.number_of_nodes(),shift)
#                 if next_g == j:
#                     ##                    next_g +=1
#                     ##                    next_g %= g
#                     continue
#                 # loop += 1
#                 #                    next_g = (next_g + loop) % g
#                 connect_to = ((next_g * a) + (next_s)) % G.number_of_nodes()
#                 x = 0
#                 while get_degree(G, connect_to, global_links) >= h:
#
#                     next_s = (next_s + 1) % a
#                     connect_to = ((next_g * a) + (next_s)) % G.number_of_nodes()
#                     #print(next_s)
#                     x += 1
#                     if x >= a:
#                         break
#                         #                print(i,j,next_g, (next_s + shift) % G.number_of_nodes(),shift)
#                 if get_degree(G, switch, global_links) >= h or get_degree(G, connect_to, global_links) >= h:
#                     continue
#
#                 #print("(1)switch :", switch, "(", i, ",", j, ")", "->", "(", next_s, ",", next_g, ") , switch :", connect_to)
#                 if G.has_edge(switch, connect_to):
#                     # print(switch , connect_to)
#
#                     if (switch, connect_to) in global_links:
#                         # G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                         G[switch][connect_to]['wight'] += t
#                         global_links[(switch, connect_to)] += t
#                     else:
#                         global_links[(switch, connect_to)] = t
#                 else:
#                     global_links[(switch, connect_to)] = t
#                     G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=t,
#                                dire={(switch, connect_to): 1})
#
#     elif gl_arrangmnt == 'palmtree':  # relative
#
#         for j in range(g):
#             for i in range(a):
#                 for k in range(1, h + 1):
#                     dg = ((j + 1 + (((a - i - 1) * h + k - 1)) % (g - 1)))%g #extend
#                     #dg = (j - (i * h) - k) % g  # original
#                     ds = (a - i - 1) % a
#                     #print(((a * j) + i), "->", "(", i, ",", j, ")", "->", "(", ds, ",", dg % g, ")", "->", ((a * dg) + ds))
#                     switch = (j * a) + i
#                     connect_to = (a * dg) + ds
#
#                     if G.has_edge(switch, connect_to):
#                         # print(switch , connect_to)
#                         if (switch, connect_to) in global_links:
#                             G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                     else:
#                         global_links[(switch, connect_to)] = 1
#                         G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                    dire={(switch, connect_to): 1})
#
#
#         # for indx, switch in enumerate(list(G.nodes())):
#         #     g_id = switch // a
#         #     s_id = switch % a
#         #
#         #     #            if indx >= math.ceil(len(list(G.nodes()))/2):
#         #     #                break
#         #
#         #     #            done = 1
#         #     #            for s in list(G.nodes()):
#         #     #
#         #     #                if G.degree(s) <= h:
#         #     #                    done = 0
#         #     #
#         #     #            if done:
#         #     #                break,'consecutive','consecutive2'
#         #
#         #     for x in range(1, h + 1):
#         #
#         #         next_g = (g_id + 1 + (((a - s_id - 1) * h + x - 1)) % (g - 1)) % g
#         #         # next_g_1 = (g_id - s_id * h -x) % g
#         #         # next_s_1 = a - 1 - s_id
#         #         next_s = a - s_id - 1
#         #         connect_to = (next_g * a) + next_s
#         #         # connect_to = (next_g_1 * a) + next_s_1
#         #         # print("(1)switch :",switch,"(",s_id,",",g_id,")","->","(",next_s,",",next_g,") , switch :" ,connect_to)
#         #         # print("(2)switch :",switch,"(",s_id,",",g_id,")","->","(",next_s_1,",",next_g_1,") , switch :" ,connect_to,"\n")
#         #         if switch == connect_to:
#         #             continue
#         #
#         #         # if G.degree(switch) >= degree:
#         #         #                        continue
#         #
#         #         # print("(1)switch :",switch,"(",s_id,",",g_id,")","->","(",next_s,",",next_g,") , switch :" ,connect_to)
#         #         if G.has_edge(switch, connect_to):
#         #             # print(switch , connect_to)
#         #
#         #             if (switch, connect_to) in global_links:
#         #                 # G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#         #                 G[switch][connect_to]['wight'] += 1
#         #                 global_links[(switch, connect_to)] += 1
#         #             else:
#         #                 global_links[(switch, connect_to)] = 1
#         #         else:
#         #             global_links[(switch, connect_to)] = 1
#         #             G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#         #                        dire={(switch, connect_to): 1})
#         #
#         #             #            for switch in list(G.nodes()):
#         #             #                if  get_degree(G,switch,global_links) <= degree :
#         #             #                    nodes = list(G.nodes())
#         #             #                    for sw in nodes[next_g * a:(next_g * a)+a]:
#         #             #                        if G.degree(sw)< degree:
#         #             #                            connect_to = sw
#         #             #                            break
#
#     elif gl_arrangmnt == 'circulant':
#         for switch in list(G.nodes()):
#             g_id = switch // a
#             s_id = switch % a
#             done = 0
#
#             for s in list(G.nodes()):
#                 done = 1
#                 if get_degree(G, s, global_links) <= h:
#                     done = 0
#             if G.degree(switch) >= degree:
#                 continue
#             if done:
#                 break
#
#             for x in range(0, (h // (2))):
#                 for o in ops:
#                     op_func = ops[o]
#                     result = op_func(g_id, (((h // 2) * s_id + x) % (g - 1 // 2)) + 1)
#                     next_s = s_id
#                     next_g = result % g
#                     connect_to = (next_g * a) + next_s
#
#                     # print("(1)switch :",switch,"(",s_id,",",g_id,")","->","(",next_s,",",next_g,") , switch :" ,connect_to)
#                     if switch == connect_to:
#                         continue
#
#                     # S_count = 0
#                     #                    while G.degree(connect_to) >= degree and S_count < G.number_of_nodes() - 1 :
#                     #                        connect_to += 1
#                     #                        connect_to %= G.number_of_nodes()
#                     #                        S_count += 1
#                     #                    print("not continued")
#                     if G.has_edge(switch, connect_to):
#                         # print(switch , connect_to)
#                         if (switch, connect_to) in global_links:
#                             # G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                     else:
#                         global_links[(switch, connect_to)] = 1
#                         G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                    dire={(switch, connect_to): 1})
#
#     elif gl_arrangmnt == 'random':
#
#         group_fill = [[0, x, deque([(x * a) + y for y in range(a)]), [0] * g] for x in range(g)]
#
#         for group in group_fill:
#             random.shuffle(group[2])
#         # print(group_fill)
#
#         while sum([x[0] for x in group_fill]) < g * a * h:
#             # print(sum([x[0] for x in group_fill]), g*a*h)
#             srcDst = []
#             random.shuffle(group_fill)
#             for i in range(2):
#                 minG = min(group_fill, key=lambda x: x[0])
#                 while len(srcDst) > 1 and minG[1] == srcDst[0]:
#                     random.shuffle(group_fill)
#                     print("in the loop")
#                     minG = min(group_fill, key=lambda x: x[0])
#                 minG[0] += 1
#                 srcDst += [minG[1], minG[2][-1]]
#                 # print(get_degree(G, minG[2][-1] , global_links))
#                 if get_degree(G, minG[2][-1],
#                               global_links) == h - 1:  # get_degree(global_links=global_links,G=G,sw=minG[2][-1])
#                     minG[2].pop()
#             src_g, src, dest_g, dest = srcDst
#             assert (src_g != dest_g)
#             assert (src != dest)
#
#             connect_to = dest
#             switch = src
#
#             if G.has_edge(switch, connect_to):
#                 # G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                 G[switch][connect_to]['wight'] += 1
#                 global_links[(switch, connect_to)] += 1
#                 global_links[(connect_to, switch)] += 1
#             else:
#                 global_links[(switch, connect_to)] = 1
#                 global_links[(connect_to, switch)] = 1
#                 G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                            dire={(switch, connect_to): 1})
#                 # print(best_asp,nx.average_shortest_path_length(G))
#     elif gl_arrangmnt == 'random2':
#
#         group_fill = [[0, x, deque([(x * a) + y for y in range(a)]), [0] * g] for x in range(g)]
#
#         for group in group_fill:
#             random.shuffle(group[2])
#             # print(group_fill)
#         initLinks = ((x, y) for x in range(g) for y in range(x + 1, g))
#         group_fill.sort(key=lambda x: x[1])
#         while sum([x[0] for x in group_fill]) < g * a * h:
#             # print(sum([x[0] for x in group_fill]), g*a*h)
#             srcDst = []
#             if sum([x[0] for x in group_fill]) < (g * (g - 1)):
#                 for x in next(initLinks):
#                     minG = group_fill[x]
#                     minG[0] += 1
#                     srcDst += [minG[1], minG[2][-1]]
#                     if get_degree(G, minG[2][-1], global_links) == h - 1:
#                         minG[2].pop()
#             else:
#                 random.shuffle(group_fill)
#                 for i in range(2):
#                     minG = min(group_fill, key=lambda x: x[0])
#                     while len(srcDst) > 1 and minG[1] == srcDst[0]:
#                         random.shuffle(group_fill)
#                         minG = min(group_fill, key=lambda x: x[0])
#                     minG[0] += 1
#                     srcDst += [minG[1], minG[2][-1]]
#                     # print(get_degree(G, minG[2][-1] , global_links))
#                     if get_degree(G, minG[2][-1],global_links) == h - 1:  # get_degree(global_links=global_links,G=G,sw=minG[2][-1])
#                         xx = minG[2].pop()
#             src_g, src, dest_g, dest = srcDst
#             assert (src_g != dest_g)
#             assert (src != dest)
#
#             connect_to = dest
#             switch = src
#
#             if G.has_edge(switch, connect_to):
#                 # G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                 G[switch][connect_to]['wight'] += 1
#                 global_links[(switch, connect_to)] += 1
#                 global_links[(connect_to, switch)] += 1
#             else:
#                 global_links[(switch, connect_to)] = 1
#                 global_links[(connect_to, switch)] = 1
#                 G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                            dire={(switch, connect_to): 1})
#
#     elif gl_arrangmnt == 'absolute__improved':# round roubin random
#
#         total_globals = (h * a * g)//2
#         gl_count = 0
#         nodes = G.number_of_nodes()
#         g_index = 1
#         s_index = 0
#
#         for gSrc in range(g):
#
#             for sSrc in range(a):
#                 #print(gSrc , sSrc,g_index,s_index)
#                 while get_degree_global(G,(a* gSrc)+sSrc,global_links) < h:
#
#                     if gSrc != g_index and get_degree_global(G,(a* g_index)+s_index,global_links)< h:
#
#                         switch = (a * gSrc)+sSrc
#                         connect_to = (a* g_index)+s_index
#
#                         #print("(1)switch :",switch,"(",sSrc,",",gSrc,")","->","(",s_index,",",g_index,") , switch :" ,connect_to)
#                         if G.has_edge(switch, connect_to):
#
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                             global_links[(connect_to, switch)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                             global_links[(connect_to, switch)] = 1
#                             G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                        dire={(switch, connect_to): 1})
#
#
#                     g_index += 1
#                     if g_index % g == 0:
#                         s_index += 1
#                         s_index %= a
#                         g_index %= g
#
#     elif gl_arrangmnt == 'ciculant_improved':# round roubin random
#
#         total_globals = (h * a * g)//2
#         gl_count = 0
#         nodes = G.number_of_nodes()
#         g_index = 1
#         s_index = 0
#
#         for gSrc in range(g):
#
#             for sSrc in range(a):
#                 # print(gSrc , sSrc,g_index,s_index)
#                 while get_degree_global(G, (a * gSrc) + sSrc, global_links) < h//2:
#
#                     if gSrc != g_index and get_degree_global(G, (a * g_index) + s_index, global_links) < h//2:
#
#                         switch = (a * gSrc) + sSrc
#                         connect_to = (a * g_index) + s_index
#
#                         # print("(1)switch :",switch,"(",sSrc,",",gSrc,")","->","(",s_index,",",g_index,") , switch :" ,connect_to)
#                         if G.has_edge(switch, connect_to):
#
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                             global_links[(connect_to, switch)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                             global_links[(connect_to, switch)] = 1
#                             G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                        dire={(switch, connect_to): 1})
#
#                     g_index += 1
#                     if g_index % g == 0:
#                         s_index += 1
#                         s_index %= a
#                         g_index %= g
#         g_index = g - 1
#
#
#         for gSrc in range(g):
#
#             for sSrc in range(a):
#                 # print(gSrc , sSrc,g_index,s_index)
#                 while get_degree_global(G, (a * gSrc) + sSrc, global_links) < h:
#
#                     if gSrc != g_index and get_degree_global(G, (a * g_index) + s_index, global_links) < h:
#
#                         switch = (a * gSrc) + sSrc
#                         connect_to = (a * g_index) + s_index
#
#                         # print("(1)switch :",switch,"(",sSrc,",",gSrc,")","->","(",s_index,",",g_index,") , switch :" ,connect_to)
#                         if G.has_edge(switch, connect_to):
#
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                             global_links[(connect_to, switch)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                             global_links[(connect_to, switch)] = 1
#                             G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                        dire={(switch, connect_to): 1})
#
#                     g_index -= 1
#                     if g_index == 0:
#                         s_index += 1
#                         s_index %= a
#                         g_index = g - 1
#
#             for x in G.nodes():
#                 print(list(G.neighbors(x)))
#             exit(1)
#
#     elif gl_arrangmnt == 'Random_RR':# round roubin random
#         total_globals = (h * a * g)//2
#         gl_count = 0
#         nodes = G.number_of_nodes()
#         g_index = 1
#         s_index = 0
#         round_rr = 0
#
#         complete_round = (((h * a)//(g-1)) )
#         left_over_links = (((h * a)%(g-1)) )
#         #print("total global links :",total_globals , " , round :",complete_round, " , leftover: ",left_over_links)
#
#         links_per_groups = [0] * g
#
#         #groups = list(range(g))
#
#         #print("left over links:",left_over_links)
#         for gSrc in range(g):
#
#
#             for sSrc in range(a):
#
#                 if links_per_groups[gSrc] == (a * h) - left_over_links:
#                     continue
#
#                 while get_degree_global(G,(a* gSrc)+sSrc,global_links) < h:
#
#                     if gSrc != g_index and get_degree_global(G,(a* g_index)+s_index,global_links)< h and links_per_groups[gSrc] <= (a * h ) - left_over_links:
#
#                         switch = (a * gSrc)+sSrc
#                         connect_to = (a* g_index)+s_index
#
#                         links_per_groups[gSrc] += 1
#                         links_per_groups[g_index] += 1
#                         #print("(1)switch :",switch,"(",sSrc,",",gSrc,")","->","(",s_index,",",g_index,") , switch :" ,connect_to)
#                         if G.has_edge(switch, connect_to):
#
#                             G[switch][connect_to]['wight'] += 1
#                             global_links[(switch, connect_to)] += 1
#                             global_links[(connect_to, switch)] += 1
#                         else:
#                             global_links[(switch, connect_to)] = 1
#                             global_links[(connect_to, switch)] = 1
#                             G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                        dire={(switch, connect_to): 1})
#                         gl_count += 1
#
#                     g_index += 1
#                     if g_index % g == 0:
#                         s_index += 1
#                         s_index %= a
#                         g_index %= g
#                         round_rr +=1
#
#
#
#         left_over = []
#         left_over_links = (left_over_links * g)
#         link_count = 0
#         visted_node = 0
#         #print("left over links" , left_over_links)
#         if left_over_links:
#             while link_count < left_over_links:
#
#                 if visted_node >= G.number_of_nodes() - 1:
#                     break
#
#                 for switch in range(nodes):
#                     if get_degree_global(G,switch,global_links) < h:
#                         left_over.append(switch)
#                 #print(left_over)
#                 if left_over:
#                     random.shuffle(left_over)
#
#                 for sw in left_over:
#                     count_iter = 0
#                     while get_degree_global(G,sw,global_links) < h:
#                         count_iter +=1
#                         if count_iter == len(left_over):
#                             break
#                         dst = random.choice(left_over)
#
#                         if dst//a == sw//a or dst == sw or get_degree_global(G,dst,global_links) >= h:
#                             continue
#
#                         else:
#                             link_count += 1
#                             switch = sw
#                             connect_to = dst
#                             if G.has_edge(switch, connect_to):
#
#                                     G[switch][connect_to]['wight'] += 1
#                                     global_links[(switch, connect_to)] += 1
#                                     global_links[(connect_to, switch)] += 1
#                             else:
#                                     global_links[(switch, connect_to)] = 1
#                                     global_links[(connect_to, switch)] = 1
#                                     G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                                                dire={(switch, connect_to): 1})
#
#                 visted_node += 1
#
#         #print(global_links)
#     elif gl_arrangmnt == 'Random_RR2':# round roubin random
#         group_fill = [[0, x, deque([(x * a) + y for y in range(a)]), [0] * g] for x in range(g)]
#         for group in group_fill:
#             random.shuffle(group[2])
#             # print(group_fill)
#         initLinks = ((x, y) for x in range(g) for y in range(x + 1, g))
#         initLks = len(list(initLinks))
#         total_globals = (h * a * g)//2
#         mult = total_globals // initLks
#
#         group_fill.sort(key=lambda x: x[1])
#         while sum([x[0] for x in group_fill]) < g * a * h:
#             if sum([x[0] for x in group_fill]) % initLks == 0 and sum([x[0] for x in group_fill]) < mult * initLks:
#                 initLinks = ((x, y) for x in range(g) for y in range(x + 1, g))
#             # print(sum([x[0] for x in group_fill]), g*a*h)
#             srcDst = []
#             if sum([x[0] for x in group_fill]) < (g * (g - 1)):
#                 for x in next(initLinks):
#                     minG = group_fill[x]
#                     minG[0] += 1
#                     srcDst += [minG[1], minG[2][-1]]
#                     if get_degree(G, minG[2][-1], global_links) == h - 1:
#                         minG[2].pop()
#             else:
#                 random.shuffle(group_fill)
#                 for i in range(2):
#                     minG = min(group_fill, key=lambda x: x[0])
#                     while len(srcDst) > 1 and minG[1] == srcDst[0]:
#                         random.shuffle(group_fill)
#                         minG = min(group_fill, key=lambda x: x[0])
#                     minG[0] += 1
#                     srcDst += [minG[1], minG[2][-1]]
#                     # print(get_degree(G, minG[2][-1] , global_links))
#                     if get_degree(G, minG[2][-1],global_links) == h - 1:  # get_degree(global_links=global_links,G=G,sw=minG[2][-1])
#                         xx = minG[2].pop()
#             src_g, src, dest_g, dest = srcDst
#             assert (src_g != dest_g)
#             assert (src != dest)
#
#             connect_to = dest
#             switch = src
#
#             if G.has_edge(switch, connect_to):
#                 # G[switch][connect_to]['dire'][(switch, connect_to)] += 1
#                 G[switch][connect_to]['wight'] += 1
#                 global_links[(switch, connect_to)] += 1
#                 global_links[(connect_to, switch)] += 1
#             else:
#                 global_links[(switch, connect_to)] = 1
#                 global_links[(connect_to, switch)] = 1
#                 G.add_edge(switch, connect_to, type="global", color=(0.0, 0.0, 1.0), w=3, wight=1,
#                            dire={(switch, connect_to): 1})
#     temp = dict()
#
#     for switch, connect_to in list(G.edges()):
#         if G[switch][connect_to]['type'] == 'global':
#
#             if (switch, connect_to) in global_links:
#                 t1 = global_links[(switch, connect_to)]
#             else:
#                 t1 = 0
#
#             if (connect_to, switch) in global_links:
#                 t2 = global_links[(connect_to, switch)]
#             else:
#                 t2 = 0
#
#             max_w = max(t1, t2)
#
#             for link in [(switch, connect_to), (connect_to, switch)]:
#                 temp[link] = dict()
#                 temp[link]['w'] = max_w  # G[switch][connect_to]['wight']
#                 temp[link]['load'] = 0
#                 temp[link]['count'] = 0
#
#     global_links = temp
#
#     return G, global_links


def build_drgonfly_groups(a, p, h, g):
    # g (number of groups in the system)
    # a (number of routers in each group)
    # p (number of servers connected to each router)
    # h (number of glbal links from a switch)
    local_links = {}
    '''
    create intera-group connections 
    '''
    G = nx.Graph()
    swtchs_ids = list(range(g * a))
    # print(swtchs_ids)
    for sub_group in range(g):
        # print(swtchs_ids[sub_group * a:((sub_group + 1) * a)])
        sub_G = nx.complete_graph(swtchs_ids[sub_group * a:((sub_group + 1) * a)])
        G = nx.compose(G, sub_G)

    labels = 'local'
    color = (0.0, 0.0, 0.0)
    wight = 1
    dire = dict()

    nx.set_edge_attributes(G, values = labels, name = 'type')
    nx.set_edge_attributes(G, values = color, name = 'color')
    nx.set_edge_attributes(G, values = wight, name = 'wight')
    nx.set_edge_attributes(G, values = dire, name = 'dire')

    for u, v in list(G.edges()):
        G[u][v]['dire'] = {(u, v): 1}
        local_links[(u, v)] = dict()
        local_links[(u, v)]['w'] = 1
        local_links[(u, v)]['load'] = 0
        local_links[(u, v)]['count'] = 0

        G[u][v]['dire'][(v, u)] = 1
        local_links[(v, u)] = dict()
        local_links[(v, u)]['w'] = 1
        local_links[(v, u)]['load'] = 0
        local_links[(v, u)]['count'] = 0
    return G, local_links


'''
Dragonfly topology
'''


def build_drgonfly(a, p, h, gl_arrangmnt, g=None):
    
    #print("inside build_dragonfly(). a,p,h,gl_arrangmnt, g : ",a,p,h, gl_arrangmnt, g)
    
    if not g:
        g = a * h + 1

    G, local_links = build_drgonfly_groups(a, p, h, g=g)
    '''
    create inter-group connections 
    '''

    # G = arrange_global_link(G , g , a , h ,gl_arrangmnt)
    G, global_links = arrang_global_link_smart(G, g, a, h, gl_arrangmnt, local_links)
    #    print(
    #        "Topology name : Dragonfly ({})\nNumber of Groups:{}\nNnumber of links: {}\nNnumber of Swithes: {}\nSwitch per Group:{}\n".format(
    #            gl_arrangmnt, g, G.number_of_edges(), G.number_of_nodes(), a))
    return G, local_links, global_links


def get_bisect(G):
    return nxmetis.partition(G, 2)[0]


def draw_graph(G, a, i, arrgs,x):
    i = i + 1
    # labels = dict((i, i%a) for i in G.nodes())
    labels = dict((i, str(i % a) + " , " + str(i)) for i in G.nodes())
    colors = [G[u][v]['color'] for u, v in G.edges()]

    options = {
        'node_color': 'red',
        'node_size': 120,
        'width': 1,
        'labels': labels,
        'edge_color': colors,
    }

    plt.subplot(math.ceil(x/2), 2, i)
    plt.title(arrgs)
    nx.draw_circular(G, **options)


def draw_graph2(G, a, i, arrgs):
    # labels = dict((i, i%a) for i in G.nodes())
    labels = dict((i, str(i % a) + " , " + str(i)) for i in G.nodes())
    colors = [G[u][v]['color'] for u, v in G.edges()]

    options = {
        'node_color': 'red',
        'node_size': 120,
        'width': 1,
        'labels': labels,
        'edge_color': colors,
    }

    plt.title(arrgs)
    nx.draw_circular(G, **options)
    plt.show()

def load_balance(src_dest_list):
    pass
def Gene_random_prem(list_G,all_result,n):

    avr = [[]] * len(list_G)
    for _ in range(15):
        perm1 = list(list_G[0].nodes())
        perm2 = list(list_G[0].nodes())

        random.shuffle(perm1)
        random.shuffle(perm2)

        perm1 = deque(perm1)
        perm2 = deque(perm2)

        perm_list = []
        for _ in range(list_G[0].number_of_nodes()):

            n1 = perm1.popleft()

            l = len(perm2)
            for _ in range (l):
                temp = perm2.popleft()
                if temp == n1:
                    perm2.append(temp)
                else:
                    n2 = temp
                    break

            perm_list.append((n1,n2))


        for indx,G in enumerate(list_G):

            G1 = G.to_directed()
            nx.set_node_attributes(G1, 0, 'd')

            for n1,n2 in perm_list:
                G1.node[n1]['d'] += 1
                G1.node[n2]['d'] -= 1

            avr[indx].append(flowCost)

#    for i,av in enumerate(avr):
#        all_result[i]['perm_max_flow'] = sum(av)/len(av)

    return all_result


    print("flow cost :" ,sum(avr)/len(avr))
    
def random_prem(G, global_links, local_links, aggr , src_dest_list):

    avr = [] 
    for _ in range(15):
        perm1 = list(list_G[0].nodes())
        perm2 = list(list_G[0].nodes())

        random.shuffle(perm1)
        random.shuffle(perm2)

        perm1 = deque(perm1)
        perm2 = deque(perm2)

        perm_list = []
        for _ in range(list_G[0].number_of_nodes()):

            n1 = perm1.popleft()

            l = len(perm2)
            for _ in range (l):
                temp = perm2.popleft()
                if temp == n1:
                    perm2.append(temp)
                else:
                    n2 = temp
                    break

            perm_list.append((n1,n2))

        link_usage(G, global_links, local_links, aggr , src_dest_list)
        
                    
            #avr[indx].append(flowCost)

#    for i,av in enumerate(avr):
#        all_result[i]['perm_max_flow'] = sum(av)/len(av)

    return all_result


    print("flow cost :" ,sum(avr)/len(avr))
            
    
    

def link_usage(G, global_links, local_links, aggr , src_dest_list):
    all_pathes = []

    #    counts_pa ths_len = [0] * 10
    #    count_pathes = 0
    results = {'name': aggr, 'avr_l_local': 0, 'avr_l_global': 0, 'over_all_load': 0, 'local_max': 0, 'global_max': 0,
               'local_min': 0, 'global_min': 0, 'link_load_local': [], 'link_load_global': [], 'link_load_all': 0,
               'global_links': global_links, 'local_links': local_links, 'count_pathes': 0, 'counts_paths_len': {},
               'sum_load_local': 0, 'sum_load_global': 0, 'g_l_count': 0, 'l_l_count': 0,'nodes_with_more_sh':{},'max_flow':[]}
    count = 0

#    for src in list(G.nodes()):
#        for dest in list(G.nodes()):
    for src , dest in src_dest_list:
        if src == dest:
            continue
        #results['max_flow'].append(  nx.minimum_cut(G,capacity='wight',s=src,t=dest)[0])
        count += 1
        
        all_pathes = list(nx.all_shortest_paths(G, source=src, target=dest, weight='w'))
        pathlen = len(all_pathes[0]) - 1
        if len(all_pathes) in results['nodes_with_more_sh']:
            results['nodes_with_more_sh'][len(all_pathes)] += 1
        else:
            results['nodes_with_more_sh'][len(all_pathes)] = 1

        #            for p in all_pathes:
        #                #if len(p) - 2 > 2:
        #                    #print(p)
        #                    #return G
        #                results['counts_paths_len'][len(p) - 2] += 1
        #                results['count_pathes'] += 1

        if pathlen in results['counts_paths_len']:
            results['counts_paths_len'][pathlen] += 1
        else:
            results['counts_paths_len'][pathlen] = 1

        max_edg_wight_list = [1] * len(all_pathes)

        for indx,path in enumerate(all_pathes):
            # total_load += (len(path)-1)/len(all_pathes)
            max_edg_wight = 1
            for n in range(len(path) - 1):

                if (path[n], path[n + 1]) in results['local_links']:
                    max_edg_wight =  max(results['local_links'][(path[n], path[n + 1])]['w'],max_edg_wight)
                    
                elif (path[n], path[n + 1]) in results['global_links']:
                    max_edg_wight =  max(results['global_links'][(path[n], path[n + 1])]['w'],max_edg_wight)
                    
            max_edg_wight_list[indx] = max_edg_wight

        for indx ,path in enumerate(all_pathes):
            for n in range(len(path) - 1):

                if (path[n], path[n + 1]) in results['local_links']:
                    results['local_links'][(path[n], path[n + 1])]['count'] += 1
                    results['local_links'][(path[n], path[n + 1])]['load'] += (max_edg_wight_list[indx] / sum(max_edg_wight_list)) #* results['local_links'][(path[n], path[n + 1])]['w'])
                elif (path[n], path[n + 1]) in results['global_links']:

                    results['global_links'][(path[n], path[n + 1])]['count'] += 1
                    results['global_links'][(path[n], path[n + 1])]['load'] += (
                    max_edg_wight_list[indx] / sum(max_edg_wight_list)) #* results['global_links'][(path[n], path[n + 1])]['w'])
                else:
                    print("edge (", path[n], ",", path[n + 1], ") not exist")

                        # print("src",src , "dest",dest ,"\npaths\n",all_pathes,"\n\n")
    # print("total load :",total_load)
    results['local_min'] = G.number_of_nodes()
    results['global_min'] = G.number_of_nodes()

    results['g_l_count'] = (sum([x['w'] for x in results['global_links'].values()]))
    results['l_l_count'] = (sum([x['w'] for x in results['local_links'].values()]))

    for edg in results['local_links']:
        # results['local_links'][edg]['load'] = (results['local_links'][edg]['load'] # / results['local_links[edg]']['w'])
        results['sum_load_local'] += results['local_links'][edg]['load']
        results['local_min'] = min(results['local_min'], results['local_links'][edg]['load'])
        results['local_max'] = max(results['local_max'], results['local_links'][edg]['load'])

    results['avr_l_local'] = results['sum_load_local'] / results['l_l_count']

    for edg in global_links:
        # global_links[edg]['load'] = (global_links[edg]['load'] / global_links[edg]['w'])
        results['sum_load_global'] += results['global_links'][edg]['load']
        results['global_max'] = max(results['global_max'], results['global_links'][edg]['load'])
        results['global_min'] = min(results['global_min'], results['global_links'][edg]['load'])

    results['avr_l_global'] = results['sum_load_global'] / results['g_l_count']

    results['over_all_load'] = (results['sum_load_local'] + results['sum_load_global']) / (results['g_l_count'] + results['l_l_count'])

    results['link_load_all'] = np.array(
        [x['load'] for x in results['global_links'].values()] + [x['load'] for x in results['local_links'].values()])
    results['link_load_local'] = np.array([x['load'] for x in results['local_links'].values()])
    results['link_load_global'] = np.array([x['load'] for x in results['global_links'].values()])

    for e1, e2 in list(G.edges()):

        if G[e1][e2]['type'] == "local":
            color1 = (results['local_links'][(e1, e2)]['load'] - results['local_min']) / (
            results['local_max'] - results['local_min'] + 0.001)
            color2 = (results['local_links'][(e2, e1)]['load'] - results['local_min']) / (
            results['local_max'] - results['local_min'] + 0.001)
            G[e1][e2]['color'] = (0.5, color1, 0.0)

        else:
            color1 = (results['global_links'][(e1, e2)]['load'] - results['global_min']) / (
            results['global_max'] - results['global_min'] + 0.001)
            color2 = (results['global_links'][(e2, e1)]['load'] - results['global_min']) / (
            results['global_max'] - results['global_min'] + 0.001)
            G[e1][e2]['color'] = (color1, 0.5, 0.0)

    return G, results

'''
print out the final results
'''

def print_the_result(G, results, gl_arrangmnt, g, a):
    
    if (style_Flag):
        print(Style.RESET_ALL)
        print(Style.BRIGHT)
        print(Back.MAGENTA)
        print(Fore.GREEN) 
    print("\n\n\n################################\n\n\n")
    print("Topology name : Dragonfly ({})\nNumber of Groups:{}\nNnumber of Swithes: {}\nSwitch per Group:{}\n".format(
        gl_arrangmnt, g, G.number_of_nodes(), a))
    #print(Back.GREEN)
    
    if (style_Flag): 
        print(Style.NORMAL)
        print(Fore.RED) 
    
    print("####Global links statistics###\n")
    
    if (style_Flag): 
        print(Style.RESET_ALL)
        print(Fore.BLUE)
        print(Style.BRIGHT)
        
    print("total number of global links :", sum([x['w'] for x in results['global_links'].values()]))
    print("avrage link load (global): ", results['avr_l_global'])
    
    if (style_Flag):
        print(Fore.MAGENTA)
    print("max link load (global) : ", results['global_max'])
    
    if (style_Flag):    
        print(Fore.BLUE)
        
    print("min link load (global) : ", results['global_min'])
    print("links varience (global):", np.var(results['link_load_global']))
    print("total load on (glbal):", results['sum_load_global'])
    print("total links :", results['g_l_count'])
    
    if (style_Flag):
        print(Style.RESET_ALL)
        print(Fore.RED + "###############################\n")
        print(Back.GREEN)
        
    print("\n\n####Local links statistics###")
        
    if (style_Flag):
        print(Style.RESET_ALL)
        print(Fore.BLUE)
        print(Style.BRIGHT)
        
    print("total number of local links :", sum([x['w'] for x in results['local_links'].values()]))
    print("avrage link load (local): ", results['avr_l_local'])
    
    if (style_Flag):
        print(Fore.MAGENTA + "max link load (local) : ", results['local_max'])
        print(Fore.BLUE)
    
    print("min link load (local) : ", results['local_min'])
    print("links varience (local):", np.var(results['link_load_local']))
    print("total load on (local)", results['sum_load_local'])
    print("total links :", results['l_l_count'])
    
    if (style_Flag):
        print(Style.RESET_ALL)
        print(Fore.RED + "\n###############################\n")
        print(Back.GREEN)
    
    print("\n\n####overall links statistics###")
    
    if (style_Flag):
        print(Style.RESET_ALL)
        print(Fore.BLUE)
        print(Style.BRIGHT)
    
    print("avrage link load (overall)= ", results['over_all_load'])
    print("links varience (overall):", np.var(results['link_load_all']))
    
    if (style_Flag):
        print(Style.RESET_ALL)
        print(Fore.RED + "\n###############################\n")
        print(Back.GREEN)
        print(Fore.RED) 
    
    print("\n\n####pathes  statistics###\n")
    
    if (style_Flag):
        print(Style.RESET_ALL)
        print(Fore.BLUE)
        print(Style.BRIGHT)
        
    #print("\nMax flow :",min(results['max_flow']))
    for x in results['counts_paths_len']:
        print("shortest path with %d hope(s):  %d out of %d pathes = %.2f  " % (x, results['counts_paths_len'][x],
                                                                      (a * g) * (a * g - 1),
                                                                      results['counts_paths_len'][x] / (
                                                                      (a * g) * (a * g - 1))))
    for x in results['nodes_with_more_sh']:
        print("number of communication with %d path(s) :  %d out of %d pathes = %.2f  " % (x, results['nodes_with_more_sh'][x],
                                                                      sum(results['nodes_with_more_sh'].values()),
                                                                      results['nodes_with_more_sh'][x] / (
                                                                      sum(results['nodes_with_more_sh'].values()))))    
    results['bw'] = 0
    #results['bw'] = get_bisect(G)
    #print("The Bisection bandwidth : ", results['bw'])
    # calculate avrage shortest path based on moore bound
    x = 0
    opt_avr_s_p = []
    n = a * g
    sd = n * (n - 1)
    degree = (a // 2) + (a - 1)

    path_length = 1
    while sum(opt_avr_s_p) < sd :
        opt_avr_s_p += [min((n * degree) ** path_length, sd - sum(opt_avr_s_p)) * path_length]
        path_length += 1

    results['avr_shp_opt'] = sum(opt_avr_s_p) / sd
    print("optimal avrage shortest path:", results['avr_shp_opt'])
    print("optimal shortest path:")
    results['avr_shp'] = sum([results['counts_paths_len'][x] * x for x in results['counts_paths_len']]) / (
    (a * g) * (a * g - 1))
    print("avrage shortest path  : ", results['avr_shp'])
    print("all to all connections : ", ((a * g) * (a * g - 1)))
    #for edg, data in results['global_links'].items():

    if (style_Flag):
        print(Fore.RED + "\n###############################\n")
          
    #    file_name = results['name'] +"_" + str(results['a']) +"_"+  str(results['g'])
    #    
    #    with open(file_name,'w') as fd:
    #        fd.write(str(results['a']) + " " + str(results['a'])+" " + str(results['a']//2) + " "+ str(results['g']) +"\n")
    #        
    #        for edg, data in results['global_links'].items():
    #            for x in range(data['w']):
    #                sg = edg[0] // results['a']
    #                dg = edg[1] // results['a']
    #                ss = edg[0] % results['a']
    #                ds = edg[1] % results['a']
    #                #print(edg)
    #                # fd.write(str(ss)+" "+str(sg)+" "+str(ds)+" "+str(dg)+"\n")
                
                
           
    # write_adj_list_to_a_file_booksim(G,'df',a//2)
    # run_booksim()
'''
function to parse command line arguments
'''

def parse_args():

    a = 8
    g = 9
    i = 15
    isomorfic = True
    parser = argparse.ArgumentParser()
    parser.add_argument("-a", metavar='',
                        help='number of switches per group')
    parser.add_argument("-g", metavar='',
                        help='number of groups')
    parser.add_argument("-i", metavar='',
                        help='number of itration for a random2')
    parser.add_argument("-f", metavar='',
                        help='check if graphs are isomorphic')

    args = parser.parse_args()

    if args.a:
        a = int(args.a)

    if args.g:
        g = int(args.g)
    
    if args.i:
        i = int(args.i)   
    
    if args.f:
        isomorfic = True     
        
    #print("in parse_args. a,g,i: ", a,g,i)
    return (a,g,i,isomorfic)
"""
the main function
"""
graphs = []
def main(link_arrngment):
   
    
    a,g,iterations,isomorfic= parse_args()
    global graphs
    links = []
    avr_glbal = []
    avr_local = []
    all_result = []
#    iterations = 10


    # which = 1
#    for g in range(9, 10):
        # plt.close('all')
    #fig, ax = plt.subplots(nrows=2, ncols=2)
    for indx, arrg in enumerate(link_arrngment):
        #print("\n\n")
        #print(indx,arrg)
        #if arrg != 'random2' and arrg != 'Random_RR' and arrg != 'Random_RR2':
        if "random" not in arrg:
            G, local_links, global_links = build_drgonfly(a=a, p=a // 2, h=a // 2, gl_arrangmnt=arrg, g=g)

            try:
                for node in list(G.nodes()):
                    assert(get_degree_global2(G,node,global_links) == a//2) 
                    
            except :
                print(node," ,",arrg ," failed ",get_degree_global2(G,node,global_links) ," correct degree is :",a//2)
                continue
            try:
                for edg in global_links:
                    assert((edg[0],edg[1]) not in local_links) 
                    
            except :
                print(edg ," is in global and local links ",arrg)
                continue 
            
            links.append((global_links, local_links))
            G, best_results = link_usage(G, global_links, local_links, arrg,list(permutations(list(G.nodes()),2)))
            best_results['a'] = a
            best_results['g'] = g

            all_result.append(best_results)
            print_the_result(G, best_results, arrg, g, a)                ###########################################

            #draw_graph(G, a, indx, arrg,len(link_arrngment))
            graphs.append(G)

        else:
            #print("HERE")
            best_g = nx.Graph()
            best_avrage = float("inf")
            # best_avr_sh = float("inf")
            best_global_max = float("inf")
            ave_path = []
            var = []
            results = {}
            best_results = {}

            for x in tqdm(range(iterations)): 
                G, local_links, global_links = build_drgonfly(a=a, p=a // 2, h=a // 2, gl_arrangmnt=arrg, g=g)
#                
#                try:
#                    for node in list(G.nodes()):
#                        assert(get_degree_global(G,node,global_links) == a//2) 
#                except :
#                    break
                try:
                    for edg in global_links:
                        assert((edg[0],edg[1]) not in local_links) 
                        
                except :
                    print(edg ," is in global and local links ",arrg)
                    continue 

                G, results = link_usage(G, global_links, local_links, arrg,list(permutations(list(G.nodes()),2)))
                #G, results = link_usage(G, global_links, local_links, arrg)
                ave_path.append([results['avr_l_global']])
                var.append([math.sqrt(np.var(results['link_load_global']))])
                if results['over_all_load'] < best_global_max:
                    best_g = G
                    best_global_max = results['over_all_load']
                    best_results = results


            best_results['a'] = a
            best_results['g'] = g
            #random_prem_flows(best_g,global_links,local_links,arrg,best_results)

            all_result.append(best_results)
            print_the_result(best_g, best_results, arrg, g, a)  #####################
            #draw_graph(best_g, a, indx, arrg,len(link_arrngment))
            graphs.append(best_g)

#            kde = KernelDensity(bandwidth=0.01).fit(ave_path)
#            y_ax = np.linspace(min(ave_path)[0] * 0.95, max(ave_path)[0] * 1.05, 1000)[:, np.newaxis]
#            log_dens = kde.score_samples(y_ax)
#
#            prob_dist = np.exp(log_dens) / sum(np.exp(log_dens))
#            f_dist = prob_dist
#
#            plt.subplot(3, 2, 5)
#            plt.title('global links (max load)')
#            plt.plot(y_ax[:, 0], f_dist)
#            # plt.show()
#
#            kde = KernelDensity(bandwidth=0.01).fit(var)
#            y_ax = np.linspace(min(var)[0] * 0.95, max(var)[0] * 1.05, 1000)[:, np.newaxis]
#            log_dens = kde.score_samples(y_ax)
#
#            prob_dist = np.exp(log_dens) / sum(np.exp(log_dens))
#            f_dist = prob_dist
#
#            plt.subplot(3, 2, 6)
#            plt.title('global links (max load var)')
#            plt.plot(y_ax[:, 0], f_dist)

            # plt.show()
    #random_prem_flows(graphs, all_result)
    if isomorfic :        
        for i in range(len(graphs)-1):
            for j in range(i+1,len(graphs)):
                if nx.is_isomorphic(graphs[i],graphs[j]):
                    print(link_arrngment[i]," and ",link_arrngment[j],'is isomorphic')

                
                
    print(Style.BRIGHT)
    #    print (Back.CYAN + "{:<20} {:<30} {:<20} {:<20} {:<20} {:<20} {:<20} {:<20} {:<20}".format('config (a,h,g)', 'Arrangment Name',
    #                                                                                        'max load(g/l)', 'avg load (g/l/all)',
    #                                                                                        '#global links', 'avg sh path',
    #                                                                                        'avg sh path (opt)',
    #                                                                                        'bi bw','perm mf'))
    #    
    print ("{:<20} {:<30} {:<20} {:<20} {:<20} {:<20} {:<20} {:<20} {:<20}".format('config (a,h,g)', 'Arrangment Name',
                                                                                        'max load(g/l)', 'avg load (g/l/all)',
                                                                                        '#global links', 'avg sh path',
                                                                                        'avg sh path (opt)',
                                                                                        'bi bw','perm mf'))
    
    print(Style.RESET_ALL)
    for i, v in enumerate(all_result):
        print ("{:<20} {:<30} {:<20} {:<20} {:<20} {:<20} {:<20} {:<20}  {:<20}".format(
            "\t(" + str(v['a']) + ',' + str(v['a'] // 2) + ',' + str(v['g']) + ')', v['name'], str(round(v['global_max'], 2))+
            '/'+str(round(v['local_max'], 2)),str(round(v['avr_l_global'], 2))+
            '/'+str(round(v['avr_l_local'], 2))+"/"+str(round(v['over_all_load'],2)), round(v['g_l_count']//2, 2), round(v['avr_shp'], 2),
            round(v['avr_shp_opt'], 2), v['bw'],0) )

#    for indx,G in enumerate(graphs):
#        draw_graph(G, a, indx, all_result[indx]['name'], len(graphs))
#    print(Style.RESET_ALL)
#    plt.show()
##       
    
    return links ,all_result



if __name__ == '__main__':
    print("Hello World from dragonflyv2")
    
    random.seed(42)
    
    start_time = time.time()
    print("Execution started at: ", start_time)
    
    #link_arrngment =['absolute','relative','circulant','absolute_improved','absolute_improved2','random','greedy_random','leftover_greedy_random1','leftover_greedy_random2']
    link_arrngment =['absolute','relative','circulant','absolute_improved','absolute_improved2','random','greedy_random','leftover_greedy_random1','leftover_greedy_random2']
    #link_arrngment =['absolute_improved']
    
    links,all_result = main(link_arrngment) 
    
    end_time = time.time()
    print("Execution ended at: ", end_time)
    print("execution time: --- %s seconds ---" % (end_time - start_time))

    
    print("The world never says hello back!")