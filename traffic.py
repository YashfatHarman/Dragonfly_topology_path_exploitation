#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Mar  8 16:19:06 2018

@author: oem
"""

from collections import deque
import random 
from itertools import permutations

'''
By Zaid.
'''
def traffic_pattrens(n,t='all',s=0):

    if t == 'perm':
        perm1 = list(range(n))
        perm2 = list(range(n))
    
        random.shuffle(perm1)
        random.shuffle(perm2)
    
        perm1 = deque(perm1)
        perm2 = deque(perm2)
    
        perm_list = []
        for _ in range(n):
    
            n1 = perm1.popleft()
    
            l = len(perm2)
            for _ in range (l):
                temp = perm2.popleft()
                if temp == n1:
                    perm2.append(temp)
                else:
                    n2 = temp
                    break
    
            perm_list.append((n1,n2))
            
    elif t == 'shift':
        perm_list = []
        for src in range(n):
            dest = (src + s ) % n
            perm_list.append((src,dest))

    elif t == 'all':
        perm_list = list(permutations(list(range(n)),2))  
    
    else:
        raise Exception('unknown traffic')
    #print(len(perm_list))
    return perm_list   
                    
     
def create_random_permutation_pattern(a, g, *, h = 0, p = 0, seed = 0, verbose = False):
    '''
    Returns a list of <src router, dst router> tuples.
    
    However, it does account for the PEs. Say, if p == 4, then each router has
    4 PEs attached to it. Each of the 4 PEs will be matched with a dest PE.
    Then each (srcPE, dstPE) will be converted to the appropriate (src_router, dst_router)
    pair. So in this case, in the output each route will show up exactly 4 times as
    both src and dst.
    
    Update:
        Now it returns a list of (src_PE, dst_PE) pairs. If the previous router_pairs are 
        needed, implement a switch.
    
    '''
    random.seed(seed)
    
    if h == 0:
        h = a // 2
    if p == 0:
        p = a//2
    
    print("creating random permutation pattern for a: {}  g: {}  h: {}  p: {}  seed: {}".format(a,g,h,p,seed))
    
    #get total number of PEs in a list
    #shuffle
    #generate a list of (src,dst) tuples from the list (idx, value)
    
    totPE = a * g * p
    #print("totPE:", totPE)
    
    lst = [x for x in range(totPE)]
    #print("lst:", lst)
    
    random.shuffle(lst)
    #print("lst after shuffle:", lst)
    
    SDpairs_PE = [(idx,lst[idx]) for idx in range(totPE)]
    #print("SDpairs_PE:", SDpairs_PE)
    
    #SDpairs = [(src//p, dst//p) for (src,dst) in SDpairs_PE if src//p != dst//p]
    SDpairs = SDpairs_PE
    
    if verbose:
        print("SDpairs:", SDpairs)
    print("total SD pairs:", len(SDpairs))
        
    return SDpairs

    #what to do to eliminate cases where src == dst?
        #modified fischer-yates shuffle. For the time being dont worry about it.
    
    pass

def create_shift_traffic_pattern_old(a, g, *, h = 0, p = 0,  shift_by = 1, verbose = False):
    '''
    Shifts the traffic by group. Default is shift by one group.
    
    Returns a list of <src router, dst router> tuples.
    
    Works in router level. Say, if p == 4, then each router has
    4 PEs attached to it. Each of the 4 PEs will be matched with a dest PE.
    Then each (srcPE, dstPE) will be converted to the appropriate (src_router, dst_router)
    pair.
    
    Update: 
        changed to work in PE level. If router level traffic is needed, implement a switch.
    
    '''
    if h == 0:
        h = a // 2
    if p == 0:
        p = a//2
    
    print("creating shift pattern for a: {}  g: {}  h: {}  p: {}  shift_by: {}".format(a,g,h,p, shift_by))
    
    #get total number of PEs in a list
    #find the PE that is one group :  a * p PEs away
    #generate a list of (src,dst) tuple
    
    totPE = a * g * p
    print("totPE:", totPE)
    
    SDpairs_PE = [(idx, (idx + shift_by*a*p)%totPE ) for idx in range(totPE)]
    #print("SDpairs_PE:", SDpairs_PE)
    
    #    SDpairs = [(src//p, dst//p) for (src,dst) in SDpairs_PE if src//p != dst//p]
    SDpairs = SDpairs_PE
    
    if verbose:
        print("SDpairs:", SDpairs)
    
    print("total SD pairs:", len(SDpairs))
        
    return SDpairs

    pass

def create_shift_traffic_pattern(a, g, *, h = 0, p = 0,  shift_by = 1, shift_by_router = 0, router_level = False, verbose = False):
    '''
    Shifts the traffic by group. Default is shift by one group.
    After shifting by group, shifts by shift_by_router inside the group.
    
    Returns a list of <src router, dst router> tuples.
    
    Works in router level. Say, if p == 4, then each router has
    4 PEs attached to it. Each of the 4 PEs will be matched with a dest PE.
    Then each (srcPE, dstPE) will be converted to the appropriate (src_router, dst_router)
    pair.
    
    Update: 
        changed to work in PE level. If router level traffic is needed, implement a switch.
    
    '''
    if h == 0:
        h = a // 2
    if p == 0:
        p = a//2
    
    print("creating shift pattern for a: {}  g: {}  h: {}  p: {}  shift_by: {}  shift_by_router: {}  router_level: {}".format(a,g,h,p, shift_by, shift_by_router, router_level))
    
    #get total number of PEs in a list
    #find the PE that is one group :  a * p PEs away
    #generate a list of (src,dst) tuple
    
    if router_level == True:
        p = 1   # Hack. Because p is set to 1, now each router behaves like a PE.
    
    totPE = a * g * p
    
    SDpairs_PE = [None for idx in range(totPE)]
    
    for src_PE in range(totPE):
        src_router = src_PE//p
        src_PE_idx = src_PE % p
        src_group = src_router//a
        src_router_in_group = src_router % a
        
        dst_group = (src_group+shift_by) % g
        dst_router_in_group = (src_router_in_group + shift_by_router) % a
        dst_router = dst_group * a + dst_router_in_group
        dst_PE_idx = src_PE_idx
        dst_PE = dst_router * p + dst_PE_idx
        SDpairs_PE[src_PE] = (src_PE, dst_PE)
        
    #print("SDpairs_PE:", SDpairs_PE)
    
    #    SDpairs = [(src//p, dst//p) for (src,dst) in SDpairs_PE if src//p != dst//p]
    SDpairs = SDpairs_PE
    
    if verbose:
        print("SDpairs:", SDpairs)
    
    print("total SD pairs:", len(SDpairs))
        
    return SDpairs

    pass


def create_df_wc_traffic_pattern(a, g, *, h = 0, p = 0,  seed = 0, verbose = False):
    '''
    Randomly permutes the DF groups and associate each group to a destination group.
    For each destination group, shuffle the routers inside.
    
    Then each router in the src group will be mapped to the corresponding router in the dest group after shuffling.

    Returns a list of <src router, dst router> tuples.
    
    Update: 
        changed to work in PE level. If router level traffic is needed, implement a switch.
    
    '''
    if h == 0:
        h = a // 2
    if p == 0:
        p = a//2
    
    print("creating df_wc pattern for a: {}  g: {}  h: {}  p: {}  seed: {}".format(a,g,h,p, seed))
    
    #get total number of PEs in a list
    #find the PE that is one group :  a * p PEs away
    #generate a list of (src,dst) tuple
    
    totPE = a * g * p
    print("totPE:", totPE)
    
    random.seed(seed)
    
    shuffled_groups = [x for x in range(g)]
    random.shuffle(shuffled_groups)
    if verbose:
        print("shuffled groups:", shuffled_groups)
    
    shuffled_routers = [ [y for y in range(a)] for x in range(g)]
    for group in range(g):
        random.shuffle(shuffled_routers[group])
    
    if verbose:
        for idx, group in enumerate(shuffled_routers):
            print(idx, " : ", group)
    
    SDpairs_PE = [None for idx in range(totPE)]
    for idx in range(totPE):
        src_router = idx//p
        src_PE_idx = idx % p
        src_group = src_router // a
        src_router_idx = src_router % a
        dst_group = shuffled_groups[src_group]
        dst_router_idx = shuffled_routers[dst_group][src_router_idx]
        dst_router = dst_group * a + dst_router_idx
        dst_PE = dst_router * p + src_PE_idx
        SDpairs_PE[idx] = (idx, dst_PE)  
        
    
    print("total SDpairs:", len(SDpairs_PE))
    if verbose:
        for src, dst in SDpairs_PE:
            print(src,dst)
        
    return SDpairs_PE

    pass

def check_pattern_for_duplicates(pattern, verbose = False):
    '''
    takes a pattern. Checks if it has duplicate pairs.
    
    Input: pattern -> a list of (s,d) pair tuples
    Output: a list of ((s,d), frequency) tuples.
    '''
    
    dicty = {}
    
    for tup in pattern:
        if tup in dicty:
            dicty[tup] += 1
        else:
            dicty[tup] = 1
            
    freq = [(k,v) for k,v in dicty.items()]
    
    if verbose:
        for tup in freq:
            print(tup)
        
    print("total unique pairs:", len(freq))
    
    return freq
    
    pass

if __name__ == "__main__":
    print("Hello World!")
    create_shift_traffic_pattern(4, 5, verbose = True, shift_by = 1, shift_by_router=1)
    #create_random_permutation_pattern(4, 5, seed = 10, verbose = True)
    #create_df_wc_traffic_pattern(4, 5, h = 0, p = 0,  seed = 0, verbose = False)
    print("The world never says hello back!")
    pass