import networkx as nx
from djkstra import all_pair_all_shortest_paths_djkstra
from jains import jains_model, jains_model_with_unique_pairs
from path_manipulation import create_MIN_paths_list, create_VLB_paths_list, merge_MIN_and_VLB_paths
from traffic import create_random_permutation_pattern, check_pattern_for_duplicates
#from FloydWarshall import FloydWarshall, floyd_warshall_wrapper, get_path

import matplotlib.pyplot as plt

import time
import topologies as tp
import utilites as ut
import copy
    
def create_graph():
    N = 4
    graph = [[] for x in range(N)]
    
    edges = [ (0,1,1),(1,2,1),(2,3,1), (3,0,1), ]    #(src, dest, weight)
    
    #    for (src,dst,weight) in edges:
    #        graph[src].append((dst, weight))
    #        graph[dst].append((src, weight))
    #    
    #    print("the graph:")
    #    for idx in range(len(graph)):
    #        print(idx, graph[idx])
    #
    
    G = nx.Graph()
    for (src,dst,weight) in edges:
        G.add_edge(src,dst, w = weight, cap = 1)
    
    #    print("the graph from networkx:")
    #    print(G.edges(data = True))
    #    
    return G
    
    pass

def create_dragonfly(a, g, arrangement, seed = 0):
    
    start_time = time.time()
    G, local_links, global_links = tp.build_drgonfly(a=a, p=a // 2, h=a // 2, gl_arrangmnt=arrangement, g=g, seed = seed)
    end_time = time.time()
    
    print("topology creation time:", end_time - start_time)
    
    if ut.validate_DF(G,global_links,local_links,a,g):
        print("Valid topology")
        validity = "Valid"
    else:
        print("Invalid topology")
        validity = "Invalid"
    
    return G
    
    pass

def draw_graph(G):
    '''
    G needs to be a networkX Graph object.
    Each edge has a property 'w', which is basically the weight of the edge.
    '''
    #print(G.edges(data = True))
    
    pos = nx.shell_layout(G, scale = 1)
    nx.draw(G, pos = pos , with_labels = True, node_size = 500)
    edge_labels = nx.get_edge_attributes(G,"w")
    nx.draw_networkx_edge_labels(G, pos = pos, edge_labels = edge_labels)
    pass

def draw_graph_circular(G, a = 1, *, global_only = False, edge_label = False, filename = None):
    plt.figure(figsize = (6,6))
        
    colors = ['orange', 'red','cyan','blue','yellow','magenta', 'lightgreen', 'slategray','coral', 'brown', 'gold', 'lightpink', ]
    
    colors2 = [ "","lightpink", "", "blue",]
    
    reds = set()
    

    if global_only:
        edges = []
        for edge in G.edges(data = True):
            edges.append(edge)
            print(edge, edge[0], edge[1])
            if edge[0] == 0 and edge[1] == 8:
                reds.add((edge[0], edge[1]))
                reds.add((edge[1], edge[0]))
            if edge[0] == 2 and edge[1] == 9:
                reds.add((edge[0], edge[1]))
                reds.add((edge[1], edge[0]))
            
        for edge in edges:
            #print(edge)
            if edge[2]["w"] == 1:
                G.remove_edge(edge[0], edge[1])
    
    print("reds:", reds)    
    
    node_colors = [colors[(x//a)%len(colors)] for x in G.nodes]
    edge_colors = ["red" if (edge[0],edge[1]) in reds else colors2[edge[2]["w"]] for edge in G.edges(data=True)]
   
    options = {
        "node_color" : node_colors,
        "width" : 1,
        "edge_color" : edge_colors,
        "with_labels": True,
        "node_size" : 600
    }
    
    
    #nx.draw_circular(G, **options)
    pos = nx.circular_layout(G) 
    
    nx.draw(G, pos = pos , **options)
        
    if edge_label:
        edge_labels = nx.get_edge_attributes(G,"w")
        nx.draw_networkx_edge_labels(G, pos = pos, edge_labels = edge_labels)
    
    if filename:
        plt.savefig(filename, format = "png", bbox_inches='tight')
    #plt.show()
    pass

def print_graph(G):
    '''
    G is the networkx graph object
    '''
    print("\nTotal nodes:", len(G))
    #all nodes
    for node in G.nodes:
        print(node, " -> ", list(nx.all_neighbors(G,node)))
    
    #all edges
    #print(G.edges(data= True))
    pass

def create_traffic_pattern():
    '''
    For the time being, create a really simplistic pattern. Will handle complex ones later.
    '''
    pattern = [(2,1), (3,10)]
    return pattern

    pass


def test_jm():
    #create a very simplistic network
    #create network graph
    G = create_graph()
    
    #draw the network
    draw_graph_circular(G)
    
    #create SD pair list
    traffic = create_traffic_pattern()
    
    print("traffic pattern:")
    for pair in traffic:
        print(pair)
    
    traffic_and_freqs = check_pattern_for_duplicates(traffic)
    
    
    #create path list
    #paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w", print_paths = True)
    
    #paths = create_MIN_paths_list(G, traffic, all_pair_min_paths = None, verbose = True)
    
    paths = create_VLB_paths_list(G, traffic, all_pair_min_paths = None, mode = 0, verbose = False)
    
    #call jains
    #res = jains_model(G = G, sd = traffic, pp = 0, nn = len(G),  pl=vlb_paths)
    
    #total_bw, res = jains_model(G = G, traffic = traffic,   path_list = paths, verbose = True)
    
    total_bw, res = jains_model_with_unique_pairs(G = G, traffic_and_freqs = traffic_and_freqs,   path_list = paths, verbose = True)
    
    print(total_bw, res)
    
    '''
    To measure Jains for Dragonfly:
        1. Create a Drgonfly network (absolute improved will do)
                : start with a small one. Go bigger gradually.
        2. Create a traffic pattern (PE-level randperm?)
        3. Create path list
                : Needs to consider VLB paths, but initially we may want to test with min paths
                : This is where we make changes according to our routing strategy
        4. Call Jains. Let it run. Measure times.
    '''
    pass


def test_path_creation():
    print("inside test_path_creation ...")
    # create a small DF
    a = 8
    g = 20
    
    arrangement = "absolute_improved"
    
    G = create_dragonfly(a, g, arrangement)
    
    # draw it
    draw_graph_circular(G, a = a)
    
    # get a simplistic traffic pattern
    #traffic = create_traffic_pattern()
    traffic = create_random_permutation_pattern(a = a, g = g, seed = 0, verbose = False)
    traffic_and_freqs = check_pattern_for_duplicates(traffic)
    
    # call the path manipulation fuction you want to test
    #paths = create_VLB_paths_list(G, a, traffic, all_pair_min_paths = None, mode = 3, verbose = True)
    
    for mode in range(4):
        print("mode:", mode)
        paths = merge_MIN_and_VLB_paths(G, a, traffic, all_pair_min_paths = None, mode = mode, verbose = False)
        total_bw, res = jains_model_with_unique_pairs(G = G, traffic_and_freqs = traffic_and_freqs,   path_list = paths, verbose = False)
        print(total_bw, res)
        
    pass


def test_output_flushing():
    #needs to run with "python3 -u" flag.
    for ii in range(10):
        print("ii: ", ii)
        print("going to sleep for 20 secs")
        time.sleep(20)
        print("wake up.")
    
    pass

def test_datetime():
    now = datetime.datetime.now()
    print(now)
    print(now.year)
    print(now.month)
    print(now.day)
    print(now.hour)
    print(now.minute)
    print(now.second)
    a = 16
    g = 20
    routing = "combined"
    outfilename = "a_{}_g_{}_routing_{}_datetime_{}_{}_{}_{}_{}_{}.res".format(a,g,routing,now.year, now.month, now.day, now.hour, now.minute, now.second)
    print(outfilename)
    pass

def arrangment_test(topology_name,a=4,g=3,h=2, verbose = True):
    
    global_link = []
    
    if topology_name  == 'absolute_improved':
        
        print("creating {} for a {} g {} h {}".format(topology_name, a, g, h))
        
        nodes = a * g
        
        dg = 1
        ds = 0
        
        node_degree = [0] * nodes
        print("node_degree:", node_degree)
        for j in range(g):
            print("\ngroup, j: ",j)
            for i in range(a):
                print("    inside group id,i: ",i)
                while node_degree[(j*a)+i] < h:
                    print("        dest group {}, dest node {}".format(dg,ds))        
                    if dg != j and node_degree[(a* dg)+ds]< h:
                        node_degree[(a*j)+i] += 1
                        node_degree[(a*dg)+ds] += 1
                        print("            src {}, dst {} | src node degree {}, dst node degree {}".format((a*j)+i, (a*dg)+ds, node_degree[(a*j)+i], node_degree[(a*dg)+ds]))

                        global_link.append(((j * a) + i, (dg * a) + ds))
                    else:
                        print("            src {}, dst {} | src node degree {}, dst node degree {}. Skipping.".format((a*j)+i, (a*dg)+ds, node_degree[(a*j)+i], node_degree[(a*dg)+ds]))
                        
                    dg += 1
                    if dg % g == 0:
                        ds += 1
                        ds %= a
                        dg %= g  #basically, reinitializing dg to zero
    
    '''
    - absolute improved2: this will iterate over group instead of the nodes inside the groups.
    '''
    
    if topology_name == "absolute_improved2":
        nodes = a * g
        dg = 1
        ds = 0
        
        node_degree = [0] * nodes

        for i in range(a):
            for j in range(g):
                
                while node_degree[(j*a)+i] < h:
                            
                    if dg != j and node_degree[(a* dg)+ds]< h:

                        node_degree[(a*j)+i] += 1
                        node_degree[(a*dg)+ds] += 1
                        global_link.append(((j * a) + i, (dg * a) + ds))

                    dg += 1
                    if dg % g == 0:
                        ds += 1
                        ds %= a
                        dg %= g
    
    
def test_FloydWarshall(a, g, arrangement):
#    G = create_graph()
#    draw_graph(G)
#    
    G = create_dragonfly(a, g, arrangement)
    draw_graph_circular(G, a)
    floyd_warshall_wrapper(G, verbose = True)
    
    
if __name__ == "__main__":
    print("Hello world!")
    #print("today we are going to test jain's method")
    
    #test_jm()
    #test_path_creation()
    a = 4
    g = 5
    #h = 2
    arrangement = "absolute_improved"
    #arrangment_test(arrangement,a = a, g = g, h = h, verbose = True)
    
    G = create_dragonfly(a, g, arrangement)
    # draw it
    filename = "a{}_g{}_colored.png".format(a,g)
    draw_graph_circular(G, a = a, global_only = True, filename = filename)
    print_graph(G)
    
    #test_FloydWarshall(a, g, arrangement)
    
    print("The world never says hello back.")